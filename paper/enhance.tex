

The three algorithms start out by ordering the tests into a set 
based on the coverage and order passed to the algorithm.
Coverages used in our experiments are statement
and function level while orders used in our experiments are absolute,
relative, random, original order and time order. The set is ordered
in that the tests with the highest number of coverage elements
is ordered to be the first element of the set followed by the test with
the second highest number of coverage elements as the second
element of the set and so on. For more information regarding how the coverage
and order affects the ordering of tests refer to Section~\ref{sec:background}.
The three algorithms then utilizes the function processDependentTests
with the ordered set of tests to reorder its dependent tests.
The function is shown in Figure~\ref{fig:processDT}.
The processDependentTests function creates a empty set (line 1)
then goes through each test in $\mathit{T}$ and tries to add each
test to the new set (line 2-4), taking into account its dependences
when adding a test. This newly generated set has the first test
that is added to it as the first element of the set followed by the
test that is added after the first test as the second element of the set
and so on.


In order to add a test to the new set, processDependentTests calls
the recursive function, addDependentTest. The function is recursive
because test $\mathit{a}$ may depend on test $\mathit{b}$ and test
$\mathit{b}$ may depend on test $\mathit{c}$... Since it's
undetermined how many tests may need to be added before or after
test $\mathit{a}$, we solved this problem by making addDependentTest
a recursive function. addDependentTest first checks whether the test
being added is already contained in the new set, if it is then the
test will be ignored (line 1). Otherwise the function retrieves all
tests that when executed after this test will cause this test to be
dependent (line 2) and adds all of those tests to the new set first
by recursively calling this method with them (line 3-5). Once all
the tests that needs to come before this test has been added to
the new set, the test itself is added to the set (line 6). The
function concludes by recursively adding all tests that when executed
before this test will cause it to be dependent to the new set (line 7-9).     

\begin{figure}[t]
	processDependentTests($\mathit{T}):$\\
	\textbf{Input}: a ordered set of tests $\mathit{T}$\\
	\textbf{Output}: a set of tests $\mathit{dtFreeTests}$\\
	\vspace{-5mm}
	\begin{algorithmic}[1]
		\STATE $\mathit{dtFreeTests}$ $\leftarrow$ $\emptyset$
		\FOR{each $\mathit{t}$ in $\mathit{T}$}
			\STATE $\mathit{dtFreeTests}$ $\leftarrow$
			addDependentTest($\mathit{dtFreeTests}$, $\mathit{t}$)	
		\ENDFOR
		\RETURN $\mathit{dtFreeTests}$
	\end{algorithmic}

	addDependentTest($\mathit{dtFreeTests}$, $\mathit{t}):$\\
	\textbf{Input}: a set of tests $\mathit{dtFreeTests}$,
	a test $\mathit{t}$\\
	\textbf{Output}: a set of tests $\mathit{dtFreeTests}$\\
	\vspace{-5mm}
	\begin{algorithmic}[1]
		\IF{$\mathit{t}$ $\notin$ $\mathit{dtFreeTests}$}
			\STATE $\mathit{afterTests}$ $\leftarrow$
			$\mathit{getDependentAfterTests}$($\mathit{t}$)
			\FOR{each $\mathit{at}$ in $\mathit{afterTests}$}
				\STATE $\mathit{dtFreeTests}$ $\leftarrow$
				addDependentTest($\mathit{dtFreeTests}$, $\mathit{at}$)
			\ENDFOR
			\STATE $\mathit{dtFreeTests}$ $\leftarrow$ $\mathit{dtFreeTests}$
			$\cup$ $\mathit{t}$
			\STATE $\mathit{beforeTests}$ $\leftarrow$
			$\mathit{getDependentBeforeTests}$($\mathit{t}$)
			\FOR{each $\mathit{bt}$ in $\mathit{beforeTests}$}
				\STATE $\mathit{dtFreeTests}$ $\leftarrow$
				addDependentTest($\mathit{dtFreeTests}$, $\mathit{bt}$)
			\ENDFOR
		\ENDIF
		\RETURN $\mathit{dtFreeTests}$
	\end{algorithmic}
	\vspace{-3mm}
	\caption {
		The base algorithm to process a set of test's dependent tests. The
		 processDependentTests function is utilized by various downstream
		 testing techniques. The function generates a new order for the tests
		 within $\mathit{T}$ to ensure that dependent tests will not have its
		 execution result be affected by the ordering of tests. 
	}
	\label{fig:processDT}
\end{figure}

\subsection{Enhancing Test Prioritization}
\label{sec:enhanceprio}
\begin{figure}[t]
	getPrioritizationTests($\mathit{T}$, $\mathit{coverage}$, $\mathit{order}):$\\
	\textbf{Input}: a set of tests $\mathit{T}$, coverage to consider when ordering
	tests $\mathit{coverage}$, order to consider when ordering tests $\mathit{order}$\\
	\textbf{Output}: a set of tests\\
	 \begin{algorithmic}[1]
	 	\vspace{-5mm}
		\STATE $\mathit{orderedTests}$ $\leftarrow$ orderTests($\mathit{T}$,
		$\mathit{coverage}$, $\mathit{order}$)
		\RETURN processDependentTests($\mathit{orderedTests}$)
	\end{algorithmic}
	\vspace{-3mm}
	\caption {
		The algorithm to generate a set of tests. The orderTests function orders
		a test suite's tests based on the specified coverage and order. The
		processDependentTests function is shown in Figure~\ref{fig:processDT}.
	}
	\label{fig:prioritization}
\end{figure}
As shown in Figure~\ref{fig:prioritization} this algorithm returns a
set of tests by calling the functions orderTests followed by
processDependentTests. orderTests takes a set of tests and orders them based on
the coverage and order specified. Once the tests has been
ordered, the dependent tests contained in the ordered set of tests is processed by
processDependentTests (Figure~\ref{fig:processDT}). For more information
regarding coverage, order and test prioritization refer back to
Section~\ref{sec:backgroundprio}.

\subsection{Enhancing Test Selection}
\label{sec:enhancesel}
\begin{figure}[t]
	getSelectionTests($\mathit{T}$, $\mathit{coverage}$, $\mathit{order}):$\\
	\textbf{Input}: a set of tests $\mathit{T}$, coverage to consider when ordering
	tests $\mathit{coverage}$, order to consider when ordering tests $\mathit{order}$\\
	\textbf{Output}: a selected set of tests\\
	 \begin{algorithmic}[1]
	 	\vspace{-5mm}
	 	\STATE $\mathit{changedTests}$ $\leftarrow$ getChangedTests($\mathit{T}$,
	 	$\mathit{coverage}$)
		\STATE $\mathit{orderedTests}$ $\leftarrow$ orderTests($\mathit{changedTests}$,
		$\mathit{coverage}$, $\mathit{order}$)
		\RETURN processDependentTests($\mathit{orderedTests}$)
	\end{algorithmic}
	\vspace{-3mm}
	\caption {
		The algorithm to generate a selected set of tests. The
		getChangedTests function returns tests within a test suite that has had its
		coverage elements changed. The orderTests function orders a test suite's tests
		based on the specified coverage and order. The processDependentTests function
		is shown in Figure~\ref{fig:processDT}. 
	}
	\label{fig:selection}
\end{figure}
As shown in Figure~\ref{fig:selection} this algorithm generates a selected
set of tests by calling the functions getChangedTests, orderTests and
processDependentTests. getChangedTests returns a set containing tests
that have its coverage elements changed. In test selection these are the tests
that are worth executing to determine if the changed coverage elements of these
tests will reveal different execution results. Similar to Section~\ref{sec:enhanceprio}
orderTests takes the set of changed tests and orders them based on the coverage
and order specified. For more information regarding coverage, order,
processDependentTests and test selection refer back to Sections~\ref{sec:backgroundsel}
and ~\ref{sec:enhanceprio}.

\subsection{Enhancing Test Parallelization}
\label{sec:enhancepar}
\begin{figure}[t]
	getParallelizationTests($\mathit{T}$, $\mathit{buckets}$, $\mathit{coverage}$,
	$\mathit{order}):$\\
	\textbf{Input}: a set of tests $\mathit{T}$, buckets to distribute tests to
	$\mathit{buckets}$, coverage to consider when ordering tests 
	$\mathit{coverage}$, order to consider when ordering tests $\mathit{order}$\\
	\textbf{Output}: a set of set of tests\\
	 \begin{algorithmic}[1]
	 	\vspace{-5mm}
		\STATE $\mathit{orderedTests}$ $\leftarrow$ orderTests($\mathit{T}$,
		$\mathit{coverage}$, $\mathit{order}$)
		\FOR{each $\mathit{t}$ in $\mathit{orderedTests}$}
			\STATE getLowestBucket($\mathit{buckets}$) $\leftarrow$
			getLowestBucket($\mathit{buckets}$) $\cup$ $\mathit{t}$
		\ENDFOR
		\FOR{each $\mathit{bucket}$ in $\mathit{buckets}$}
			\STATE processDependentTests($\mathit{bucket}$)
		\ENDFOR
		\RETURN $\mathit{buckets}$
	\end{algorithmic}
	\vspace{-3mm}
	\caption {
		The algorithm to generate a set of set of tests. The orderTests function
		orders a test suite's tests based on the specified coverage and order.
		The getLowestBucket function returns the set of ordered tests within
		$\mathit{buckets}$ that has the least amount of coverage elements. The
		processDependentTests function is shown in Figure~\ref{fig:processDT}. Our
		experiments used $\mathit{buckets}$ with size of 2, 4, 6, 8 and 16.
	}
	\label{fig:parallelization}
\end{figure}

As shown in Figure~\ref{fig:parallelization} this algorithm generates a set of
set of tests by calling the functions orderTests, getLowestBucket and
processDependentTests. The function starts out by ordering the tests with
orderTests (line 1). For more information regarding orderTests, coverage, order,
processDependentTests and test parallelization refer back to Sections
 ~\ref{sec:backgroundpar} and ~\ref{sec:enhanceprio}. Afterwards, starting from
the test with the highest number of coverage elements to the test with the
lowest number of coverage elements, the function makes repeated calls to
getLowestBucket. This is to retrieve the current bucket with the lowest number
of coverage elements and add the current test $\mathit{t}$ to the bucket (lines
2-4). Once all the ordered tests have been distributed to a bucket, each bucket
is called with processDependentTests to ensure that the reordering of tests
into buckets do not expose the test suite's dependent tests (lines 5-7).
