diff -r jfreechart-1.0.15/src/org/jfree/chart/annotations/Annotation.java jfreechart-1.0.16/src/org/jfree/chart/annotations/Annotation.java
49a50,51
>  * 
>  * @since 1.0.14
diff -r jfreechart-1.0.15/src/org/jfree/chart/annotations/CategoryAnnotation.java jfreechart-1.0.16/src/org/jfree/chart/annotations/CategoryAnnotation.java
54c54,56
<  * a {@link CategoryPlot}.
---
>  * a {@link CategoryPlot}. Note that, in JFreeChart 1.0.14, a non-compatible 
>  * change has been made to this interface (it now extends the Annotation
>  * interface to support change notifications).
diff -r jfreechart-1.0.15/src/org/jfree/chart/annotations/XYAnnotation.java jfreechart-1.0.16/src/org/jfree/chart/annotations/XYAnnotation.java
59c59,61
<  * an {@link XYPlot}.
---
>  * an {@link XYPlot}.  Note that, in JFreeChart 1.0.14, a non-compatible 
>  * change has been made to this interface (it now extends the Annotation
>  * interface to support change notifications).
61c63
< public interface XYAnnotation extends Annotation{
---
> public interface XYAnnotation extends Annotation {
77,78c79
<                      int rendererIndex,
<                      PlotRenderingInfo info);
---
>                      int rendererIndex, PlotRenderingInfo info);
diff -r jfreechart-1.0.15/src/org/jfree/chart/axis/Axis.java jfreechart-1.0.16/src/org/jfree/chart/axis/Axis.java
86c86,87
<  *
---
>  * 01-Aug-2013 : Added attributedLabel override to support superscripts,
>  *               subscripts and more (DG);
98a100
> import java.awt.font.TextLayout;
105a108
> import java.text.AttributedString;
117a121
> import org.jfree.chart.util.AttrStringUtils;
123a128
> import org.jfree.util.AttributedStringUtilities;
190a196,201
>     
>     /** 
>      * An attributed label for the axis (overrides label if non-null).
>      * We have to use this override method to preserve the API compatibility.
>      */
>     private transient AttributedString attributedLabel;
202a214,216
>     
>     /** The axis label location (new in 1.0.16). */
>     private AxisLabelLocation labelLocation;
298a313
>         this.labelLocation = AxisLabelLocation.MIDDLE;
322d336
< 
375a390,392
>         this.label = label;
>         fireChangeEvent();
>     }
377,388c394,437
<         String existing = this.label;
<         if (existing != null) {
<             if (!existing.equals(label)) {
<                 this.label = label;
<                 fireChangeEvent();
<             }
<         }
<         else {
<             if (label != null) {
<                 this.label = label;
<                 fireChangeEvent();
<             }
---
>     /**
>      * Returns the attributed label (the returned value is a copy, so 
>      * modifying it will not impact the state of the axis).  The default value 
>      * is <code>null</code>.
>      * 
>      * @return The attributed label (possibly <code>null</code>).
>      * 
>      * @since 1.0.16
>      */
>     public AttributedString getAttributedLabel() {
>         if (this.attributedLabel != null) {
>             return new AttributedString(this.attributedLabel.getIterator());
>         } else {
>             return null;
>         }
>     }
>     
>     /**
>      * Sets the attributed label for the axis and sends an 
>      * {@link AxisChangeEvent} to all registered listeners.  This is a 
>      * convenience method that converts the string into an 
>      * <code>AttributedString</code> using the current font attributes.
>      * 
>      * @param label  the label (<code>null</<code> permitted).
>      * 
>      * @since 1.0.16
>      */
>     public void setAttributedLabel(String label) {
>         setAttributedLabel(createAttributedLabel(label));    
>     }
>     
>     /**
>      * Sets the attributed label for the axis and sends an 
>      * {@link AxisChangeEvent} to all registered listeners.
>      * 
>      * @param label  the label (<code>null</code> permitted).
>      * 
>      * @since 1.0.16
>      */
>     public void setAttributedLabel(AttributedString label) {
>         if (label != null) {
>             this.attributedLabel = new AttributedString(label.getIterator());
>         } else {
>             this.attributedLabel = null;
390c439
< 
---
>         fireChangeEvent();
392c441,460
< 
---
>     
>     /**
>      * Creates and returns an <code>AttributedString</code> with the specified
>      * text and the labelFont and labelPaint applied as attributes.
>      * 
>      * @param label  the label (<code>null</code> permitted).
>      * 
>      * @return An attributed string or <code>null</code>.
>      * 
>      * @since 1.0.16
>      */
>     public AttributedString createAttributedLabel(String label) {
>         if (label == null) {
>             return null;
>         }
>         AttributedString s = new AttributedString(label);
>         s.addAttributes(this.labelFont.getAttributes(), 0, label.length());
>         return s;
>     }
>     
510a579,604
>     
>     /**
>      * Returns the location of the axis label.  The default is
>      * {@link AxisLabelLocation#MIDDLE}.
>      * 
>      * @return The location of the axis label (never <code>null</code>). 
>      * 
>      * @since 1.0.16
>      */
>     public AxisLabelLocation getLabelLocation() {
>         return this.labelLocation;
>     }
>     
>     /**
>      * Sets the axis label location and sends an {@link AxisChangeEvent} to
>      * all registered listeners.
>      * 
>      * @param location  the new location (<code>null</code> not permitted).
>      * 
>      * @since 1.0.16
>      */
>     public void setLabelLocation(AxisLabelLocation location) {
>         ParamChecks.nullNotPermitted(location, "location");
>         this.labelLocation = location;
>         fireChangeEvent();
>     }
1055c1149
<             return;  // no need to create entity if we canÂ´t save it anyways...
---
>             return;  // no need to create entity if we can't save it anyways...
1152d1245
< 
1154,1157c1247,1260
<         String axisLabel = getLabel();
<         if (axisLabel != null && !axisLabel.equals("")) {
<             FontMetrics fm = g2.getFontMetrics(getLabelFont());
<             Rectangle2D bounds = TextUtilities.getTextBounds(axisLabel, g2, fm);
---
>         Rectangle2D bounds = null;;
>         if (this.attributedLabel != null) {
>             TextLayout layout = new TextLayout(
>                     this.attributedLabel.getIterator(), 
>                     g2.getFontRenderContext());
>             bounds = layout.getBounds();
>         } else {
>             String axisLabel = getLabel();
>             if (axisLabel != null && !axisLabel.equals("")) {
>                 FontMetrics fm = g2.getFontMetrics(getLabelFont());
>                 bounds = TextUtilities.getTextBounds(axisLabel, g2, fm);
>             }
>         }
>         if (bounds != null) {
1171d1273
< 
1172a1275
>     }
1173a1277,1328
>     protected double labelLocationX(AxisLabelLocation location, 
>             Rectangle2D dataArea) {
>         if (location.equals(AxisLabelLocation.HIGH_END)) {
>             return dataArea.getMaxX();
>         }
>         if (location.equals(AxisLabelLocation.MIDDLE)) {
>             return dataArea.getCenterX();
>         }
>         if (location.equals(AxisLabelLocation.LOW_END)) {
>             return dataArea.getMinX();
>         }
>         throw new RuntimeException("Unexpected AxisLabelLocation: " + location);
>     }
>     
>     protected double labelLocationY(AxisLabelLocation location, 
>             Rectangle2D dataArea) {
>         if (location.equals(AxisLabelLocation.HIGH_END)) {
>             return dataArea.getMinY();
>         }
>         if (location.equals(AxisLabelLocation.MIDDLE)) {
>             return dataArea.getCenterY();
>         }
>         if (location.equals(AxisLabelLocation.LOW_END)) {
>             return dataArea.getMaxY();
>         }
>         throw new RuntimeException("Unexpected AxisLabelLocation: " + location);
>     }
>     
>     protected TextAnchor labelAnchorH(AxisLabelLocation location) {
>         if (location.equals(AxisLabelLocation.HIGH_END)) {
>             return TextAnchor.CENTER_RIGHT;
>         }
>         if (location.equals(AxisLabelLocation.MIDDLE)) {
>             return TextAnchor.CENTER;
>         }
>         if (location.equals(AxisLabelLocation.LOW_END)) {
>             return TextAnchor.CENTER_LEFT;
>         }
>         throw new RuntimeException("Unexpected AxisLabelLocation: " + location);
>     }
>     
>     protected TextAnchor labelAnchorV(AxisLabelLocation location) {
>         if (location.equals(AxisLabelLocation.HIGH_END)) {
>             return TextAnchor.CENTER_RIGHT;
>         }
>         if (location.equals(AxisLabelLocation.MIDDLE)) {
>             return TextAnchor.CENTER;
>         }
>         if (location.equals(AxisLabelLocation.LOW_END)) {
>             return TextAnchor.CENTER_LEFT;
>         }
>         throw new RuntimeException("Unexpected AxisLabelLocation: " + location);
1212c1367
<             double labelx = dataArea.getCenterX();
---
>             double labelx = labelLocationX(this.labelLocation, dataArea);
1214a1370
>             TextAnchor anchor = labelAnchorH(this.labelLocation);
1216,1217c1372
<                     (float) labely, TextAnchor.CENTER, getLabelAngle(),
<                     TextAnchor.CENTER);
---
>                     (float) labely, anchor, getLabelAngle(), TextAnchor.CENTER);
1227c1382
<             double labelx = dataArea.getCenterX();
---
>             double labelx = labelLocationX(this.labelLocation, dataArea);
1229a1385
>             TextAnchor anchor = labelAnchorH(this.labelLocation);
1231,1232c1387
<                     (float) labely, TextAnchor.CENTER, getLabelAngle(),
<                     TextAnchor.CENTER);
---
>                     (float) labely, anchor, getLabelAngle(), TextAnchor.CENTER);
1244c1399,1400
<             double labely = dataArea.getCenterY();
---
>             double labely = labelLocationY(this.labelLocation, dataArea);
>             TextAnchor anchor = labelAnchorV(this.labelLocation);
1246,1247c1402,1403
<                     (float) labely, TextAnchor.CENTER,
<                     getLabelAngle() - Math.PI / 2.0, TextAnchor.CENTER);
---
>                     (float) labely, anchor, getLabelAngle() - Math.PI / 2.0, 
>                     anchor);
1252d1407
< 
1260c1415,1416
<             double labely = dataArea.getY() + dataArea.getHeight() / 2.0;
---
>             double labely = labelLocationY(this.labelLocation, dataArea);
>             TextAnchor anchor = labelAnchorV(this.labelLocation);
1262,1263c1418,1419
<                     (float) labely, TextAnchor.CENTER,
<                     getLabelAngle() + Math.PI / 2.0, TextAnchor.CENTER);
---
>                     (float) labely, anchor, getLabelAngle() + Math.PI / 2.0, 
>                     anchor);
1266d1421
< 
1273a1429,1525
>      * Draws the axis label.
>      *
>      * @param label  the label text.
>      * @param g2  the graphics device.
>      * @param plotArea  the plot area.
>      * @param dataArea  the area inside the axes.
>      * @param edge  the location of the axis.
>      * @param state  the axis state (<code>null</code> not permitted).
>      *
>      * @return Information about the axis.
>      * 
>      * @since 1.0.16
>      */
>     protected AxisState drawAttributedLabel(AttributedString label, 
>             Graphics2D g2, Rectangle2D plotArea, Rectangle2D dataArea, 
>             RectangleEdge edge, AxisState state) {
> 
>         // it is unlikely that 'state' will be null, but check anyway...
>         ParamChecks.nullNotPermitted(state, "state");
> 
>         if (label == null) {
>             return state;
>         }
> 
>         RectangleInsets insets = getLabelInsets();
>         g2.setFont(getLabelFont());
>         g2.setPaint(getLabelPaint());
>         TextLayout layout = new TextLayout(this.attributedLabel.getIterator(),
>                 g2.getFontRenderContext());
>         Rectangle2D labelBounds = layout.getBounds();
> 
>         if (edge == RectangleEdge.TOP) {
>             AffineTransform t = AffineTransform.getRotateInstance(
>                     getLabelAngle(), labelBounds.getCenterX(),
>                     labelBounds.getCenterY());
>             Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);
>             labelBounds = rotatedLabelBounds.getBounds2D();
>             double labelx = labelLocationX(this.labelLocation, dataArea);
>             double labely = state.getCursor() - insets.getBottom()
>                             - labelBounds.getHeight() / 2.0;
>             TextAnchor anchor = labelAnchorH(this.labelLocation);
>             AttrStringUtils.drawRotatedString(label, g2, (float) labelx,
>                     (float) labely, anchor, getLabelAngle(), TextAnchor.CENTER);
>             state.cursorUp(insets.getTop() + labelBounds.getHeight()
>                     + insets.getBottom());
>         }
>         else if (edge == RectangleEdge.BOTTOM) {
>             AffineTransform t = AffineTransform.getRotateInstance(
>                     getLabelAngle(), labelBounds.getCenterX(),
>                     labelBounds.getCenterY());
>             Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);
>             labelBounds = rotatedLabelBounds.getBounds2D();
>             double labelx = labelLocationX(this.labelLocation, dataArea);
>             double labely = state.getCursor()
>                             + insets.getTop() + labelBounds.getHeight() / 2.0;
>             TextAnchor anchor = labelAnchorH(this.labelLocation);
>             AttrStringUtils.drawRotatedString(label, g2, (float) labelx,
>                     (float) labely, anchor, getLabelAngle(), TextAnchor.CENTER);
>             state.cursorDown(insets.getTop() + labelBounds.getHeight()
>                     + insets.getBottom());
>         }
>         else if (edge == RectangleEdge.LEFT) {
>             AffineTransform t = AffineTransform.getRotateInstance(
>                     getLabelAngle() - Math.PI / 2.0, labelBounds.getCenterX(),
>                     labelBounds.getCenterY());
>             Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);
>             labelBounds = rotatedLabelBounds.getBounds2D();
>             double labelx = state.getCursor()
>                             - insets.getRight() - labelBounds.getWidth() / 2.0;
>             double labely = labelLocationY(this.labelLocation, dataArea);
>             TextAnchor anchor = labelAnchorV(this.labelLocation);
>             AttrStringUtils.drawRotatedString(label, g2, (float) labelx,
>                     (float) labely, anchor, getLabelAngle() - Math.PI / 2.0, 
>                     anchor);
>             state.cursorLeft(insets.getLeft() + labelBounds.getWidth()
>                     + insets.getRight());
>         }
>         else if (edge == RectangleEdge.RIGHT) {
>             AffineTransform t = AffineTransform.getRotateInstance(
>                     getLabelAngle() + Math.PI / 2.0,
>                     labelBounds.getCenterX(), labelBounds.getCenterY());
>             Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);
>             labelBounds = rotatedLabelBounds.getBounds2D();
>             double labelx = state.getCursor()
>                             + insets.getLeft() + labelBounds.getWidth() / 2.0;
>             double labely = labelLocationY(this.labelLocation, dataArea);
>             TextAnchor anchor = labelAnchorV(this.labelLocation);
>             AttrStringUtils.drawRotatedString(label, g2, (float) labelx,
>                     (float) labely, anchor, getLabelAngle() + Math.PI / 2.0, 
>                     anchor);
>             state.cursorRight(insets.getLeft() + labelBounds.getWidth()
>                     + insets.getRight());
>         }
>         return state;
>     }
> 
>     /**
1343a1596,1599
>         if (!AttributedStringUtilities.equal(this.attributedLabel, 
>                 that.attributedLabel)) {
>             return false;
>         }
1355a1612,1614
>         if (!this.labelLocation.equals(that.labelLocation)) {
>             return false;
>         }
1409a1669,1676
>     public int hashCode() {
>         int hash = 3;
>         if (this.label != null) {
>             hash = 83 * hash + this.label.hashCode();
>         }
>         return hash;
>     }
> 
1418a1686
>         SerialUtilities.writeAttributedString(this.attributedLabel, stream);
1437a1706
>         this.attributedLabel = SerialUtilities.readAttributedString(stream);
Only in jfreechart-1.0.16/src/org/jfree/chart/axis: AxisLabelLocation.java
diff -r jfreechart-1.0.15/src/org/jfree/chart/axis/AxisLocation.java jfreechart-1.0.16/src/org/jfree/chart/axis/AxisLocation.java
119d118
< 
130a130
>     }
131a132,135
>     public int hashCode() {
>         int hash = 5;
>         hash = 83 * hash + this.name.hashCode();
>         return hash;
diff -r jfreechart-1.0.15/src/org/jfree/chart/axis/CategoryAxis3D.java jfreechart-1.0.16/src/org/jfree/chart/axis/CategoryAxis3D.java
30c30
<  * (C) Copyright 2003-2009, by Klaus Rheinwald and Contributors.
---
>  * (C) Copyright 2003-2013, by Klaus Rheinwald and Contributors.
52a53,54
>  * 01-Aug-2013 : Added attributedLabel override to support superscripts,
>  *               subscripts and more (DG);
72,73c74,75
< public class CategoryAxis3D extends CategoryAxis
<         implements Cloneable, Serializable {
---
> public class CategoryAxis3D extends CategoryAxis implements Cloneable, 
>         Serializable {
110,115c112,114
<     public AxisState draw(Graphics2D g2,
<                           double cursor,
<                           Rectangle2D plotArea,
<                           Rectangle2D dataArea,
<                           RectangleEdge edge,
<                           PlotRenderingInfo plotState) {
---
>     public AxisState draw(Graphics2D g2, double cursor, Rectangle2D plotArea,
>             Rectangle2D dataArea, RectangleEdge edge, 
>             PlotRenderingInfo plotState) {
158,159c157,163
<         state = drawLabel(getLabel(), g2, plotArea, dataArea, edge, state);
< 
---
>         if (getAttributedLabel() != null) {
>             state = drawAttributedLabel(getAttributedLabel(), g2, plotArea, 
>                     dataArea, edge, state);
>             
>         } else {
>             state = drawLabel(getLabel(), g2, plotArea, dataArea, edge, state);
>         }
161d164
< 
175,179c178,180
<     public double getCategoryJava2DCoordinate(CategoryAnchor anchor,
<                                               int category,
<                                               int categoryCount,
<                                               Rectangle2D area,
<                                               RectangleEdge edge) {
---
>     public double getCategoryJava2DCoordinate(CategoryAnchor anchor, 
>             int category, int categoryCount, Rectangle2D area, 
>             RectangleEdge edge) {
diff -r jfreechart-1.0.15/src/org/jfree/chart/axis/CategoryAxis.java jfreechart-1.0.16/src/org/jfree/chart/axis/CategoryAxis.java
97,98c97,99
<  * 02-Jul-2013 : Use ParamChecks (DG);
<  * 
---
>  * 25-Jul-2013 : Added support for URLs on category labels (DG);
>  * 01-Aug-2013 : Added attributedLabel override to support superscripts,
>  *               subscripts and more (DG);
194a196,198
>     /** Storage for the category label URLs (if any). */
>     private Map categoryLabelURLs;
>     
208d211
< 
222c225
< 
---
>         this.categoryLabelURLs = new HashMap();
248c251
<         notifyListeners(new AxisChangeEvent(this));
---
>         fireChangeEvent();
274c277
<         notifyListeners(new AxisChangeEvent(this));
---
>         fireChangeEvent();
300c303
<         notifyListeners(new AxisChangeEvent(this));
---
>         fireChangeEvent();
324c327
<         notifyListeners(new AxisChangeEvent(this));
---
>         fireChangeEvent();
348c351
<         notifyListeners(new AxisChangeEvent(this));
---
>         fireChangeEvent();
365c368,369
<      * positioning is taken into account).
---
>      * positioning is taken into account) and sends a change event to all 
>      * registered listeners.
373c377
<         notifyListeners(new AxisChangeEvent(this));
---
>         fireChangeEvent();
399c403
<         notifyListeners(new AxisChangeEvent(this));
---
>         fireChangeEvent();
438c442
<         notifyListeners(new AxisChangeEvent(this));
---
>         fireChangeEvent();
477c481
<         notifyListeners(new AxisChangeEvent(this));
---
>         fireChangeEvent();
492c496
<         notifyListeners(new AxisChangeEvent(this));
---
>         fireChangeEvent();
512,513c516,518
<      * Removes the tooltip for the specified category and sends an
<      * {@link AxisChangeEvent} to all registered listeners.
---
>      * Removes the tooltip for the specified category and, if there was a value
>      * associated with that category, sends an {@link AxisChangeEvent} to all 
>      * registered listeners.
522,523c527,529
<         this.categoryLabelToolTips.remove(category);
<         notifyListeners(new AxisChangeEvent(this));
---
>         if (this.categoryLabelToolTips.remove(category) != null) {
>             fireChangeEvent();
>         }
535c541,594
<         notifyListeners(new AxisChangeEvent(this));
---
>         fireChangeEvent();
>     }
> 
>     /**
>      * Adds a URL (to be used in image maps) to the specified category and 
>      * sends an {@link AxisChangeEvent} to all registered listeners.
>      *
>      * @param category  the category (<code>null</code> not permitted).
>      * @param url  the URL text (<code>null</code> permitted).
>      *
>      * @see #removeCategoryLabelURL(Comparable)
>      * 
>      * @since 1.0.16
>      */
>     public void addCategoryLabelURL(Comparable category, String url) {
>         ParamChecks.nullNotPermitted(category, "category");
>         this.categoryLabelURLs.put(category, url);
>         fireChangeEvent();
>     }
> 
>     /**
>      * Returns the URL for the label belonging to the specified category.
>      *
>      * @param category  the category (<code>null</code> not permitted).
>      *
>      * @return The URL text (possibly <code>null</code>).
>      * 
>      * @see #addCategoryLabelURL(Comparable, String)
>      * @see #removeCategoryLabelURL(Comparable)
>      * 
>      * @since 1.0.16
>      */
>     public String getCategoryLabelURL(Comparable category) {
>         ParamChecks.nullNotPermitted(category, "category");
>         return (String) this.categoryLabelURLs.get(category);
>     }
> 
>     /**
>      * Removes the URL for the specified category and, if there was a URL 
>      * associated with that category, sends an {@link AxisChangeEvent} to all 
>      * registered listeners.
>      *
>      * @param category  the category (<code>null</code> not permitted).
>      *
>      * @see #addCategoryLabelURL(Comparable, String)
>      * @see #clearCategoryLabelURLs()
>      * 
>      * @since 1.0.16
>      */
>     public void removeCategoryLabelURL(Comparable category) {
>         ParamChecks.nullNotPermitted(category, "category");
>         if (this.categoryLabelURLs.remove(category) != null) {
>             fireChangeEvent();
>         }
538a598,611
>      * Clears the category label URLs and sends an {@link AxisChangeEvent}
>      * to all registered listeners.
>      *
>      * @see #addCategoryLabelURL(Comparable, String)
>      * @see #removeCategoryLabelURL(Comparable)
>      * 
>      * @since 1.0.16
>      */
>     public void clearCategoryLabelURLs() {
>         this.categoryLabelURLs.clear();
>         fireChangeEvent();
>     }
>     
>     /**
549,553c622,624
<     public double getCategoryJava2DCoordinate(CategoryAnchor anchor,
<                                               int category,
<                                               int categoryCount,
<                                               Rectangle2D area,
<                                               RectangleEdge edge) {
---
>     public double getCategoryJava2DCoordinate(CategoryAnchor anchor, 
>             int category, int categoryCount, Rectangle2D area, 
>             RectangleEdge edge) {
582,584c653,654
<     public double getCategoryStart(int category, int categoryCount,
<                                    Rectangle2D area,
<                                    RectangleEdge edge) {
---
>     public double getCategoryStart(int category, int categoryCount, 
>             Rectangle2D area, RectangleEdge edge) {
601d670
< 
618c687
<                                     Rectangle2D area, RectangleEdge edge) {
---
>             Rectangle2D area, RectangleEdge edge) {
643,644c712
<                                  Rectangle2D area, RectangleEdge edge) {
< 
---
>             Rectangle2D area, RectangleEdge edge) {
647d714
< 
757,758c824
<                                            RectangleEdge edge) {
< 
---
>             RectangleEdge edge) {
778d843
< 
791,793c856,857
<     protected double calculateCategoryGapSize(int categoryCount,
<                                               Rectangle2D area,
<                                               RectangleEdge edge) {
---
>     protected double calculateCategoryGapSize(int categoryCount, 
>             Rectangle2D area, RectangleEdge edge) {
809d872
< 
811d873
< 
825,827c887,888
<     public AxisSpace reserveSpace(Graphics2D g2, Plot plot,
<                                   Rectangle2D plotArea,
<                                   RectangleEdge edge, AxisSpace space) {
---
>     public AxisSpace reserveSpace(Graphics2D g2, Plot plot, 
>             Rectangle2D plotArea, RectangleEdge edge, AxisSpace space) {
875d935
< 
923c983,989
<         state = drawLabel(getLabel(), g2, plotArea, dataArea, edge, state);
---
>         if (getAttributedLabel() != null) {
>             state = drawAttributedLabel(getAttributedLabel(), g2, plotArea, 
>                     dataArea, edge, state);
>             
>         } else {
>             state = drawLabel(getLabel(), g2, plotArea, dataArea, edge, state);
>         }
932,959d997
<      * @param dataArea  the area inside the axes (<code>null</code> not
<      *                  permitted).
<      * @param edge  the axis location (<code>null</code> not permitted).
<      * @param state  the axis state (<code>null</code> not permitted).
<      * @param plotState  collects information about the plot (<code>null</code>
<      *                   permitted).
<      *
<      * @return The updated axis state (never <code>null</code>).
<      *
<      * @deprecated Use {@link #drawCategoryLabels(Graphics2D, Rectangle2D,
<      *     Rectangle2D, RectangleEdge, AxisState, PlotRenderingInfo)}.
<      */
<     protected AxisState drawCategoryLabels(Graphics2D g2,
<                                            Rectangle2D dataArea,
<                                            RectangleEdge edge,
<                                            AxisState state,
<                                            PlotRenderingInfo plotState) {
< 
<         // this method is deprecated because we really need the plotArea
<         // when drawing the labels - see bug 1277726
<         return drawCategoryLabels(g2, dataArea, dataArea, edge, state,
<                 plotState);
<     }
< 
<     /**
<      * Draws the category labels and returns the updated axis state.
<      *
<      * @param g2  the graphics device (<code>null</code> not permitted).
974a1013,1024
>         if (!isTickLabelsVisible()) {
>             return state;
>         }
>  
>         List ticks = refreshTicks(g2, state, plotArea, edge);
>         state.setTicks(ticks);
>         int categoryIndex = 0;
>         Iterator iterator = ticks.iterator();
>         while (iterator.hasNext()) {
>             CategoryTick tick = (CategoryTick) iterator.next();
>             g2.setFont(getTickLabelFont(tick.getCategory()));
>             g2.setPaint(getTickLabelPaint(tick.getCategory()));
976,1054c1026,1038
<         if (isTickLabelsVisible()) {
<             List ticks = refreshTicks(g2, state, plotArea, edge);
<             state.setTicks(ticks);
< 
<             int categoryIndex = 0;
<             Iterator iterator = ticks.iterator();
<             while (iterator.hasNext()) {
< 
<                 CategoryTick tick = (CategoryTick) iterator.next();
<                 g2.setFont(getTickLabelFont(tick.getCategory()));
<                 g2.setPaint(getTickLabelPaint(tick.getCategory()));
< 
<                 CategoryLabelPosition position
<                         = this.categoryLabelPositions.getLabelPosition(edge);
<                 double x0 = 0.0;
<                 double x1 = 0.0;
<                 double y0 = 0.0;
<                 double y1 = 0.0;
<                 if (edge == RectangleEdge.TOP) {
<                     x0 = getCategoryStart(categoryIndex, ticks.size(),
<                             dataArea, edge);
<                     x1 = getCategoryEnd(categoryIndex, ticks.size(), dataArea,
<                             edge);
<                     y1 = state.getCursor() - this.categoryLabelPositionOffset;
<                     y0 = y1 - state.getMax();
<                 }
<                 else if (edge == RectangleEdge.BOTTOM) {
<                     x0 = getCategoryStart(categoryIndex, ticks.size(),
<                             dataArea, edge);
<                     x1 = getCategoryEnd(categoryIndex, ticks.size(), dataArea,
<                             edge);
<                     y0 = state.getCursor() + this.categoryLabelPositionOffset;
<                     y1 = y0 + state.getMax();
<                 }
<                 else if (edge == RectangleEdge.LEFT) {
<                     y0 = getCategoryStart(categoryIndex, ticks.size(),
<                             dataArea, edge);
<                     y1 = getCategoryEnd(categoryIndex, ticks.size(), dataArea,
<                             edge);
<                     x1 = state.getCursor() - this.categoryLabelPositionOffset;
<                     x0 = x1 - state.getMax();
<                 }
<                 else if (edge == RectangleEdge.RIGHT) {
<                     y0 = getCategoryStart(categoryIndex, ticks.size(),
<                             dataArea, edge);
<                     y1 = getCategoryEnd(categoryIndex, ticks.size(), dataArea,
<                             edge);
<                     x0 = state.getCursor() + this.categoryLabelPositionOffset;
<                     x1 = x0 - state.getMax();
<                 }
<                 Rectangle2D area = new Rectangle2D.Double(x0, y0, (x1 - x0),
<                         (y1 - y0));
<                 Point2D anchorPoint = RectangleAnchor.coordinates(area,
<                         position.getCategoryAnchor());
<                 TextBlock block = tick.getLabel();
<                 block.draw(g2, (float) anchorPoint.getX(),
<                         (float) anchorPoint.getY(), position.getLabelAnchor(),
<                         (float) anchorPoint.getX(), (float) anchorPoint.getY(),
<                         position.getAngle());
<                 Shape bounds = block.calculateBounds(g2,
<                         (float) anchorPoint.getX(), (float) anchorPoint.getY(),
<                         position.getLabelAnchor(), (float) anchorPoint.getX(),
<                         (float) anchorPoint.getY(), position.getAngle());
<                 if (plotState != null && plotState.getOwner() != null) {
<                     EntityCollection entities
<                             = plotState.getOwner().getEntityCollection();
<                     if (entities != null) {
<                         String tooltip = getCategoryLabelToolTip(
<                                 tick.getCategory());
<                         entities.add(new CategoryLabelEntity(tick.getCategory(),
<                                 bounds, tooltip, null));
<                     }
<                 }
<                 categoryIndex++;
<             }
< 
<             if (edge.equals(RectangleEdge.TOP)) {
<                 double h = state.getMax() + this.categoryLabelPositionOffset;
<                 state.cursorUp(h);
---
>             CategoryLabelPosition position
>                     = this.categoryLabelPositions.getLabelPosition(edge);
>             double x0 = 0.0;
>             double x1 = 0.0;
>             double y0 = 0.0;
>             double y1 = 0.0;
>             if (edge == RectangleEdge.TOP) {
>                 x0 = getCategoryStart(categoryIndex, ticks.size(), dataArea, 
>                         edge);
>                 x1 = getCategoryEnd(categoryIndex, ticks.size(), dataArea, 
>                         edge);
>                 y1 = state.getCursor() - this.categoryLabelPositionOffset;
>                 y0 = y1 - state.getMax();
1056,1058c1040,1046
<             else if (edge.equals(RectangleEdge.BOTTOM)) {
<                 double h = state.getMax() + this.categoryLabelPositionOffset;
<                 state.cursorDown(h);
---
>             else if (edge == RectangleEdge.BOTTOM) {
>                 x0 = getCategoryStart(categoryIndex, ticks.size(), dataArea, 
>                         edge);
>                 x1 = getCategoryEnd(categoryIndex, ticks.size(), dataArea, 
>                         edge);
>                 y0 = state.getCursor() + this.categoryLabelPositionOffset;
>                 y1 = y0 + state.getMax();
1061,1062c1049,1054
<                 double w = state.getMax() + this.categoryLabelPositionOffset;
<                 state.cursorLeft(w);
---
>                 y0 = getCategoryStart(categoryIndex, ticks.size(), dataArea, 
>                         edge);
>                 y1 = getCategoryEnd(categoryIndex, ticks.size(), dataArea,
>                         edge);
>                 x1 = state.getCursor() - this.categoryLabelPositionOffset;
>                 x0 = x1 - state.getMax();
1065,1066c1057,1062
<                 double w = state.getMax() + this.categoryLabelPositionOffset;
<                 state.cursorRight(w);
---
>                 y0 = getCategoryStart(categoryIndex, ticks.size(), dataArea, 
>                         edge);
>                 y1 = getCategoryEnd(categoryIndex, ticks.size(), dataArea,
>                         edge);
>                 x0 = state.getCursor() + this.categoryLabelPositionOffset;
>                 x1 = x0 - state.getMax();
1067a1064,1105
>             Rectangle2D area = new Rectangle2D.Double(x0, y0, (x1 - x0),
>                     (y1 - y0));
>             Point2D anchorPoint = RectangleAnchor.coordinates(area,
>                     position.getCategoryAnchor());
>             TextBlock block = tick.getLabel();
>             block.draw(g2, (float) anchorPoint.getX(),
>                     (float) anchorPoint.getY(), position.getLabelAnchor(),
>                     (float) anchorPoint.getX(), (float) anchorPoint.getY(),
>                     position.getAngle());
>             Shape bounds = block.calculateBounds(g2,
>                     (float) anchorPoint.getX(), (float) anchorPoint.getY(),
>                     position.getLabelAnchor(), (float) anchorPoint.getX(),
>                     (float) anchorPoint.getY(), position.getAngle());
>             if (plotState != null && plotState.getOwner() != null) {
>                 EntityCollection entities = plotState.getOwner()
>                         .getEntityCollection();
>                 if (entities != null) {
>                     String tooltip = getCategoryLabelToolTip(
>                             tick.getCategory());
>                     String url = getCategoryLabelURL(tick.getCategory());
>                     entities.add(new CategoryLabelEntity(tick.getCategory(),
>                             bounds, tooltip, url));
>                 }
>             }
>             categoryIndex++;
>         }
> 
>         if (edge.equals(RectangleEdge.TOP)) {
>             double h = state.getMax() + this.categoryLabelPositionOffset;
>             state.cursorUp(h);
>         }
>         else if (edge.equals(RectangleEdge.BOTTOM)) {
>             double h = state.getMax() + this.categoryLabelPositionOffset;
>             state.cursorDown(h);
>         }
>         else if (edge == RectangleEdge.LEFT) {
>             double w = state.getMax() + this.categoryLabelPositionOffset;
>             state.cursorLeft(w);
>         }
>         else if (edge == RectangleEdge.RIGHT) {
>             double w = state.getMax() + this.categoryLabelPositionOffset;
>             state.cursorRight(w);
1082,1085c1120,1121
<     public List refreshTicks(Graphics2D g2,
<                              AxisState state,
<                              Rectangle2D dataArea,
<                              RectangleEdge edge) {
---
>     public List refreshTicks(Graphics2D g2, AxisState state, 
>             Rectangle2D dataArea, RectangleEdge edge) {
1232c1268
<                                     RectangleEdge edge, Graphics2D g2) {
---
>             RectangleEdge edge, Graphics2D g2) {
1250d1285
< 
1260d1294
< 
1273,1275c1307
<                                               CategoryLabelPosition position,
<                                               Graphics2D g2) {
< 
---
>             CategoryLabelPosition position, Graphics2D g2) {
1285d1316
< 
1300a1332
>         clone.categoryLabelURLs = new HashMap(this.categoryLabelToolTips);
1346a1379,1382
>         if (!ObjectUtilities.equal(this.categoryLabelURLs, 
>                 that.categoryLabelURLs)) {
>             return false;
>         }
1363,1368c1399
<         if (getLabel() != null) {
<             return getLabel().hashCode();
<         }
<         else {
<             return 0;
<         }
---
>         return super.hashCode();
1479a1511,1534
>     }
> 
>     /**
>      * Draws the category labels and returns the updated axis state.
>      *
>      * @param g2  the graphics device (<code>null</code> not permitted).
>      * @param dataArea  the area inside the axes (<code>null</code> not
>      *                  permitted).
>      * @param edge  the axis location (<code>null</code> not permitted).
>      * @param state  the axis state (<code>null</code> not permitted).
>      * @param plotState  collects information about the plot (<code>null</code>
>      *                   permitted).
>      *
>      * @return The updated axis state (never <code>null</code>).
>      *
>      * @deprecated Use {@link #drawCategoryLabels(Graphics2D, Rectangle2D,
>      *     Rectangle2D, RectangleEdge, AxisState, PlotRenderingInfo)}.
>      */
>     protected AxisState drawCategoryLabels(Graphics2D g2, Rectangle2D dataArea,
>             RectangleEdge edge, AxisState state, PlotRenderingInfo plotState) {
>         // this method is deprecated because we really need the plotArea
>         // when drawing the labels - see bug 1277726
>         return drawCategoryLabels(g2, dataArea, dataArea, edge, state,
>                 plotState);
diff -r jfreechart-1.0.15/src/org/jfree/chart/axis/DateAxis.java jfreechart-1.0.16/src/org/jfree/chart/axis/DateAxis.java
129,130c129,133
<  * 02-Jul-2013 : Use ParamChecks (DG);
<  *
---
>  * 25-Jul-2013 : Update event notification to use fireChangeEvent() (DG);
>  * 01-Aug-2013 : Added attributedLabel override to support superscripts,
>  *               subscripts and more (DG);
>  * 12-Sep-2013 : Prevent exception when zooming in below 1 millisecond (DG);
>  * 
221a225
>         @Override
232a237
>         @Override
244a250
>         @Override
256a263
>         @Override
268a276
>         @Override
281a290
>         @Override
294a304
>         @Override
305a316
>         @Override
423c434
<             notifyListeners(new AxisChangeEvent(this));
---
>             fireChangeEvent();
437,440c448,449
<      * Sets the underlying timeline to use for this axis.
<      * <P>
<      * If the timeline is changed, an {@link AxisChangeEvent} is sent to all
<      * registered listeners.
---
>      * Sets the underlying timeline to use for this axis.  If the timeline is 
>      * changed, an {@link AxisChangeEvent} is sent to all registered listeners.
447c456
<             notifyListeners(new AxisChangeEvent(this));
---
>             fireChangeEvent();
483c492,493
<      * Sets the tick unit attribute.
---
>      * Sets the tick unit attribute and, if requested, sends an 
>      * {@link AxisChangeEvent} to all registered listeners.
499c509
<             notifyListeners(new AxisChangeEvent(this));
---
>             fireChangeEvent();
515c525,526
<      * Sets the date format override.  If this is non-null, then it will be
---
>      * Sets the date format override and sends an {@link AxisChangeEvent} to 
>      * all registered listeners.  If this is non-null, then it will be
522c533
<         notifyListeners(new AxisChangeEvent(this));
---
>         fireChangeEvent();
531a543
>     @Override
546a559
>     @Override
578a592
>     @Override
595c609
<         Date result = null;
---
>         Date result;
631c645
<         notifyListeners(new AxisChangeEvent(this));
---
>         fireChangeEvent();
643c657
<         Date result = null;
---
>         Date result;
679c693
<         notifyListeners(new AxisChangeEvent(this));
---
>         fireChangeEvent();
700c714
<         notifyListeners(new AxisChangeEvent(this));
---
>         fireChangeEvent();
706a721
>     @Override
735a751
>     @Override
737c753
<                                 RectangleEdge edge) {
---
>             RectangleEdge edge) {
770d785
< 
784,785c799,800
<     public double dateToJava2D(Date date, Rectangle2D area,
<                                RectangleEdge edge) {
---
>     public double dateToJava2D(Date date, Rectangle2D area, 
>             RectangleEdge edge) {
802,803c817,819
<     public double java2DToValue(double java2DValue, Rectangle2D area,
<                                 RectangleEdge edge) {
---
>     @Override
>     public double java2DToValue(double java2DValue, Rectangle2D area, 
>             RectangleEdge edge) {
881c897
<             case (DateTickUnit.MILLISECOND) :
---
>             case DateTickUnit.MILLISECOND :
897c913
<             case (DateTickUnit.SECOND) :
---
>             case DateTickUnit.SECOND :
921c937
<             case (DateTickUnit.MINUTE) :
---
>             case DateTickUnit.MINUTE :
944c960
<             case (DateTickUnit.HOUR) :
---
>             case DateTickUnit.HOUR :
969c985
<             case (DateTickUnit.DAY) :
---
>             case DateTickUnit.DAY :
998c1014
<             case (DateTickUnit.MONTH) :
---
>             case DateTickUnit.MONTH :
1017c1033
<             case(DateTickUnit.YEAR) :
---
>             case DateTickUnit.YEAR :
1110,1128d1125
<      *
<      * @return A collection of standard date tick units.
<      *
<      * @deprecated Since 1.0.11, use {@link #createStandardDateTickUnits(
<      *         TimeZone, Locale)} to explicitly set the locale as well as the
<      *         time zone.
<      */
<     public static TickUnitSource createStandardDateTickUnits(TimeZone zone) {
<         return createStandardDateTickUnits(zone, Locale.getDefault());
<     }
< 
<     /**
<      * Returns a collection of standard date tick units.  This collection will
<      * be used by default, but you are free to create your own collection if
<      * you want to (see the
<      * {@link ValueAxis#setStandardTickUnits(TickUnitSource)} method inherited
<      * from the {@link ValueAxis} class).
<      *
<      * @param zone  the time zone (<code>null</code> not permitted).
1258a1256
>     @Override
1429,1430c1427,1428
<     private double estimateMaximumTickLabelWidth(Graphics2D g2,
<                                                  DateTickUnit unit) {
---
>     private double estimateMaximumTickLabelWidth(Graphics2D g2, 
>             DateTickUnit unit) {
1530a1529
>     @Override
1558,1562c1557,1561
<             case (DateTickUnit.MILLISECOND) :
<             case (DateTickUnit.SECOND) :
<             case (DateTickUnit.MINUTE) :
<             case (DateTickUnit.HOUR) :
<             case (DateTickUnit.DAY) :
---
>             case DateTickUnit.MILLISECOND :
>             case DateTickUnit.SECOND :
>             case DateTickUnit.MINUTE :
>             case DateTickUnit.HOUR :
>             case DateTickUnit.DAY :
1564c1563
<             case (DateTickUnit.MONTH) :
---
>             case DateTickUnit.MONTH :
1568c1567
<             case(DateTickUnit.YEAR) :
---
>             case DateTickUnit.YEAR :
1824a1824
>     @Override
1845c1845,1851
<         state = drawLabel(getLabel(), g2, plotArea, dataArea, edge, state);
---
>         if (getAttributedLabel() != null) {
>             state = drawAttributedLabel(getAttributedLabel(), g2, plotArea, 
>                     dataArea, edge, state);
>             
>         } else {
>             state = drawLabel(getLabel(), g2, plotArea, dataArea, edge, state);
>         }
1852c1858,1859
<      * Zooms in on the current range.
---
>      * Zooms in on the current range (zoom-in stops once the axis length 
>      * reaches the equivalent of one millisecond).  
1856a1864
>     @Override
1859,1864c1867,1870
<             (long) getRange().getLowerBound()
<         );
<         double length = (this.timeline.toTimelineValue(
<                 (long) getRange().getUpperBound())
<                 - this.timeline.toTimelineValue(
<                     (long) getRange().getLowerBound()));
---
>                 (long) getRange().getLowerBound());
>         double end = this.timeline.toTimelineValue(
>                 (long) getRange().getUpperBound());
>         double length = end - start;
1865a1872
>         long adjStart, adjEnd;
1867,1870c1874,1875
<             adjusted = new DateRange(this.timeline.toMillisecond((long) (start
<                     + (length * (1 - upperPercent)))),
<                     this.timeline.toMillisecond((long) (start + (length
<                     * (1 - lowerPercent)))));
---
>             adjStart = (long) (start + (length * (1 - upperPercent)));
>             adjEnd = (long) (start + (length * (1 - lowerPercent)));
1873,1876c1878,1879
<             adjusted = new DateRange(this.timeline.toMillisecond(
<                     (long) (start + length * lowerPercent)),
<                     this.timeline.toMillisecond((long) (start + length
<                     * upperPercent)));
---
>             adjStart = (long) (start + length * lowerPercent);
>             adjEnd = (long) (start + length * upperPercent);
1877a1881,1888
>         // when zooming to sub-millisecond ranges, it can be the case that
>         // adjEnd == adjStart...and we can't have an axis with zero length
>         // so we apply this instead:
>         if (adjEnd <= adjStart) {
>             adjEnd = adjStart + 1L;
>         } 
>         adjusted = new DateRange(this.timeline.toMillisecond(adjStart),
>                this.timeline.toMillisecond(adjEnd));
1887a1899
>     @Override
1917a1930
>     @Override
1919,1924c1932
<         if (getLabel() != null) {
<             return getLabel().hashCode();
<         }
<         else {
<             return 0;
<         }
---
>         return super.hashCode();
1934a1943
>     @Override
1943a1953,1971
>     }
>  
>     /**
>      * Returns a collection of standard date tick units.  This collection will
>      * be used by default, but you are free to create your own collection if
>      * you want to (see the
>      * {@link ValueAxis#setStandardTickUnits(TickUnitSource)} method inherited
>      * from the {@link ValueAxis} class).
>      *
>      * @param zone  the time zone (<code>null</code> not permitted).
>      *
>      * @return A collection of standard date tick units.
>      *
>      * @deprecated Since 1.0.11, use {@link #createStandardDateTickUnits(
>      *         TimeZone, Locale)} to explicitly set the locale as well as the
>      *         time zone.
>      */
>     public static TickUnitSource createStandardDateTickUnits(TimeZone zone) {
>         return createStandardDateTickUnits(zone, Locale.getDefault());
diff -r jfreechart-1.0.15/src/org/jfree/chart/axis/LogAxis.java jfreechart-1.0.16/src/org/jfree/chart/axis/LogAxis.java
59,60c59,60
<  *
<  */
---
>  * 01-Aug-2013 : Added attributedLabel override to support superscripts,
>  *               subscripts and more (DG); */
153c153
<         notifyListeners(new AxisChangeEvent(this));
---
>         fireChangeEvent();
180c180
<         notifyListeners(new AxisChangeEvent(this));
---
>         fireChangeEvent();
224c224
<                             boolean turnOffAutoSelect) {
---
>             boolean turnOffAutoSelect) {
232c232
<             notifyListeners(new AxisChangeEvent(this));
---
>             fireChangeEvent();
259c259
<         notifyListeners(new AxisChangeEvent(this));
---
>         fireChangeEvent();
458c458,464
<         state = drawLabel(getLabel(), g2, plotArea, dataArea, edge, state);
---
>         if (getAttributedLabel() != null) {
>             state = drawAttributedLabel(getAttributedLabel(), g2, plotArea, 
>                     dataArea, edge, state);
>             
>         } else {
>             state = drawLabel(getLabel(), g2, plotArea, dataArea, edge, state);
>         }
477d482
< 
486d490
< 
690,692c694,695
<     protected void selectVerticalAutoTickUnit(Graphics2D g2,
<                                               Rectangle2D dataArea,
<                                               RectangleEdge edge) {
---
>     protected void selectVerticalAutoTickUnit(Graphics2D g2, 
>             Rectangle2D dataArea, RectangleEdge edge) {
755,756c758,759
<     protected double estimateMaximumTickLabelWidth(Graphics2D g2,
<                                                    TickUnit unit) {
---
>     protected double estimateMaximumTickLabelWidth(Graphics2D g2, 
>             TickUnit unit) {
diff -r jfreechart-1.0.15/src/org/jfree/chart/axis/NumberAxis3D.java jfreechart-1.0.16/src/org/jfree/chart/axis/NumberAxis3D.java
67c67,68
<  *
---
>  * 01-Aug-2013 : Added attributedLabel override to support superscripts,
>  *               subscripts and more (DG); *
170,172c171,176
<         // draw the axis label...
<         info = drawLabel(getLabel(), g2, plotArea, dataArea, edge, info);
< 
---
>         if (getAttributedLabel() != null) {
>             info = drawAttributedLabel(getAttributedLabel(), g2, plotArea, 
>                     dataArea, edge, info);
>         } else {
>             info = drawLabel(getLabel(), g2, plotArea, dataArea, edge, info);
>         }
diff -r jfreechart-1.0.15/src/org/jfree/chart/axis/NumberAxis.java jfreechart-1.0.16/src/org/jfree/chart/axis/NumberAxis.java
98a99,100
>  * 01-Aug-2013 : Added attributedLabel override to support superscripts,
>  *               subscripts and more (DG);
342c344
<                             boolean turnOffAutoSelect) {
---
>             boolean turnOffAutoSelect) {
522c524
<                                 RectangleEdge edge) {
---
>             RectangleEdge edge) {
562c564
<                                 RectangleEdge edge) {
---
>             RectangleEdge edge) {
661,670c663,669
< //        // draw the marker band (if there is one)...
< //        if (getMarkerBand() != null) {
< //            if (edge == RectangleEdge.BOTTOM) {
< //                cursor = cursor - getMarkerBand().getHeight(g2);
< //            }
< //            getMarkerBand().draw(g2, plotArea, dataArea, 0, cursor);
< //        }
< 
<         // draw the axis label...
<         state = drawLabel(getLabel(), g2, plotArea, dataArea, edge, state);
---
>         if (getAttributedLabel() != null) {
>             state = drawAttributedLabel(getAttributedLabel(), g2, plotArea, 
>                     dataArea, edge, state);
>             
>         } else {
>             state = drawLabel(getLabel(), g2, plotArea, dataArea, edge, state);
>         }
1189,1190c1188
<                 TextAnchor anchor = null;
<                 TextAnchor rotationAnchor = null;
---
>                 TextAnchor anchor, rotationAnchor;
1392,1397c1390
<         if (getLabel() != null) {
<             return getLabel().hashCode();
<         }
<         else {
<             return 0;
<         }
---
>         return super.hashCode();
diff -r jfreechart-1.0.15/src/org/jfree/chart/axis/PeriodAxis.java jfreechart-1.0.16/src/org/jfree/chart/axis/PeriodAxis.java
59a60,62
>  * 25-Jul-2013 : Fix for axis timezone and label formatting, bug 1107 (DG);
>  * 01-Aug-2013 : Added attributedLabel override to support superscripts,
>  *               subscripts and more (DG);
178c181
<     /** Info for each labelling band. */
---
>     /** Info for each labeling band. */
217,219c220,221
<     public PeriodAxis(String label,
<                       RegularTimePeriod first, RegularTimePeriod last,
<                       TimeZone timeZone) {
---
>     public PeriodAxis(String label, RegularTimePeriod first, 
>             RegularTimePeriod last, TimeZone timeZone) {
255,258c257,262
<         this.labelInfo[0] = new PeriodAxisLabelInfo(Month.class,
<                 new SimpleDateFormat("MMM", locale));
<         this.labelInfo[1] = new PeriodAxisLabelInfo(Year.class,
<                 new SimpleDateFormat("yyyy", locale));
---
>         SimpleDateFormat df0 = new SimpleDateFormat("MMM", locale);
>         df0.setTimeZone(timeZone);
>         this.labelInfo[0] = new PeriodAxisLabelInfo(Month.class, df0);
>         SimpleDateFormat df1 = new SimpleDateFormat("yyyy", locale);
>         df1.setTimeZone(timeZone);
>         this.labelInfo[1] = new PeriodAxisLabelInfo(Year.class, df1);
280c284
<         notifyListeners(new AxisChangeEvent(this));
---
>         fireChangeEvent();
302c306
<         notifyListeners(new AxisChangeEvent(this));
---
>         fireChangeEvent();
327c331
<         notifyListeners(new AxisChangeEvent(this));
---
>         fireChangeEvent();
361c365
<         notifyListeners(new AxisChangeEvent(this));
---
>         fireChangeEvent();
383c387
<         notifyListeners(new AxisChangeEvent(this));
---
>         fireChangeEvent();
405c409
<         notifyListeners(new AxisChangeEvent(this));
---
>         fireChangeEvent();
427c431
<         notifyListeners(new AxisChangeEvent(this));
---
>         fireChangeEvent();
450c454
<         notifyListeners(new AxisChangeEvent(this));
---
>         fireChangeEvent();
473c477
<         notifyListeners(new AxisChangeEvent(this));
---
>         fireChangeEvent();
493c497
<         notifyListeners(new AxisChangeEvent(this));
---
>         fireChangeEvent();
513c517
<         notifyListeners(new AxisChangeEvent(this));
---
>         fireChangeEvent();
533c537
<         notifyListeners(new AxisChangeEvent(this));
---
>         fireChangeEvent();
547,548c551,552
<     public void setRange(Range range, boolean turnOffAutoRange,
<                          boolean notify) {
---
>     public void setRange(Range range, boolean turnOffAutoRange, 
>             boolean notify) {
583,585c587,588
<     public AxisSpace reserveSpace(Graphics2D g2, Plot plot,
<                                   Rectangle2D plotArea, RectangleEdge edge,
<                                   AxisSpace space) {
---
>     public AxisSpace reserveSpace(Graphics2D g2, Plot plot, 
>             Rectangle2D plotArea, RectangleEdge edge, AxisSpace space) {
604,605c607
<         double labelHeight = 0.0;
<         double labelWidth = 0.0;
---
>         double labelHeight, labelWidth;
668,671c670,676
<         // draw the axis label (note that 'state' is passed in *and*
<         // returned)...
<         axisState = drawLabel(getLabel(), g2, plotArea, dataArea, edge,
<                 axisState);
---
>         if (getAttributedLabel() != null) {
>             axisState = drawAttributedLabel(getAttributedLabel(), g2, plotArea, 
>                     dataArea, edge, axisState);
>         } else {
>             axisState = drawLabel(getLabel(), g2, plotArea, dataArea, edge, 
>                     axisState);
>         } 
684,686c689,690
<     protected void drawTickMarks(Graphics2D g2, AxisState state,
<                                  Rectangle2D dataArea,
<                                  RectangleEdge edge) {
---
>     protected void drawTickMarks(Graphics2D g2, AxisState state, 
>             Rectangle2D dataArea, RectangleEdge edge) {
705,706c709
<                                            Rectangle2D dataArea,
<                                            RectangleEdge edge) {
---
>             Rectangle2D dataArea, RectangleEdge edge) {
720c723
<             ticks.add(new NumberTick(new Double(t0), "", TextAnchor.CENTER,
---
>             ticks.add(new NumberTick(Double.valueOf(t0), "", TextAnchor.CENTER,
793,794c796
<                                          Rectangle2D dataArea,
<                                          RectangleEdge edge) {
---
>             Rectangle2D dataArea, RectangleEdge edge) {
810,811c812
<                                        Rectangle2D dataArea,
<                                        RectangleEdge edge) {
---
>             Rectangle2D dataArea, RectangleEdge edge) {
835,838c836,839
<         String label1 = this.labelInfo[band].getDateFormat().format(
<                 new Date(p1.getMiddleMillisecond()));
<         String label2 = this.labelInfo[band].getDateFormat().format(
<                 new Date(p2.getMiddleMillisecond()));
---
>         DateFormat df = this.labelInfo[band].getDateFormat();
>         df.setTimeZone(this.timeZone);
>         String label1 = df.format(new Date(p1.getMiddleMillisecond()));
>         String label2 = df.format(new Date(p2.getMiddleMillisecond()));
870d870
<             DateFormat df = this.labelInfo[band].getDateFormat();
1019c1019
<         double result = Double.NaN;
---
>         double result;
1132,1137c1132
<         if (getLabel() != null) {
<             return getLabel().hashCode();
<         }
<         else {
<             return 0;
<         }
---
>         return super.hashCode();
diff -r jfreechart-1.0.15/src/org/jfree/chart/axis/PeriodAxisLabelInfo.java jfreechart-1.0.16/src/org/jfree/chart/axis/PeriodAxisLabelInfo.java
75,79d74
<     // TODO: this class is mostly immutable, so implementing Cloneable isn't
<     // really necessary.  But there is still a hole in that you can get the
<     // dateFormat and modify it.  We could return a copy, but that would slow
<     // things down. Needs resolving.
< 
164c159
<         this.dateFormat = dateFormat;
---
>         this.dateFormat = (DateFormat) dateFormat.clone();
184c179
<      * Returns the date formatter.
---
>      * Returns a copy of the date formatter.
186c181
<      * @return The date formatter (never <code>null</code>).
---
>      * @return A copy of the date formatter (never <code>null</code>).
189c184
<         return this.dateFormat;
---
>         return (DateFormat) this.dateFormat.clone();
337,338c332,333
<         result = 37 * this.periodClass.hashCode();
<         result = 37 * this.dateFormat.hashCode();
---
>         result = result + 37 * this.periodClass.hashCode();
>         result = result + 37 * this.dateFormat.hashCode();
diff -r jfreechart-1.0.15/src/org/jfree/chart/axis/SegmentedTimeline.java jfreechart-1.0.16/src/org/jfree/chart/axis/SegmentedTimeline.java
383d382
< //        timeline.setStartTime(100000l);
diff -r jfreechart-1.0.15/src/org/jfree/chart/axis/SubCategoryAxis.java jfreechart-1.0.16/src/org/jfree/chart/axis/SubCategoryAxis.java
49c49,50
<  *
---
>  * 01-Aug-2013 : Added attributedLabel override to support superscripts,
>  *               subscripts and more (DG); *
65a67
> import java.util.Objects;
268,269c270,275
<         state = drawLabel(getLabel(), g2, plotArea, dataArea, edge, state);
< 
---
>         if (getAttributedLabel() != null) {
>             state = drawAttributedLabel(getAttributedLabel(), g2, plotArea, 
>                     dataArea, edge, state);
>         } else {
>             state = drawLabel(getLabel(), g2, plotArea, dataArea, edge, state);
>         } 
407a414,417
>     }
> 
>     public int hashCode() {
>         return super.hashCode();
diff -r jfreechart-1.0.15/src/org/jfree/chart/axis/SymbolAxis.java jfreechart-1.0.16/src/org/jfree/chart/axis/SymbolAxis.java
203c203
<             notifyListeners(new AxisChangeEvent(this));
---
>             fireChangeEvent();
230c230
<         notifyListeners(new AxisChangeEvent(this));
---
>         fireChangeEvent();
261c261
<         notifyListeners(new AxisChangeEvent(this));
---
>         fireChangeEvent();
644,646c644,645
<     protected List refreshTicksVertical(Graphics2D g2,
<                                         Rectangle2D dataArea,
<                                         RectangleEdge edge) {
---
>     protected List refreshTicksVertical(Graphics2D g2, Rectangle2D dataArea,
>             RectangleEdge edge) {
diff -r jfreechart-1.0.15/src/org/jfree/chart/axis/Timeline.java jfreechart-1.0.16/src/org/jfree/chart/axis/Timeline.java
100c100
<      * This is because the original tranformation may not be complete
---
>      * This is because the original transformation may not be complete
diff -r jfreechart-1.0.15/src/org/jfree/chart/axis/ValueAxis.java jfreechart-1.0.16/src/org/jfree/chart/axis/ValueAxis.java
64c64
<  * 27-Nov-2002 : Moved the 'inverted' attributed from NumberAxis to
---
>  * 27-Nov-2002 : Moved the 'inverted' attribute from NumberAxis to
370c370
<             notifyListeners(new AxisChangeEvent(this));
---
>             fireChangeEvent();
397c397
<         notifyListeners(new AxisChangeEvent(this));
---
>         fireChangeEvent();
423c423
<         notifyListeners(new AxisChangeEvent(this));
---
>         fireChangeEvent();
450c450
<         notifyListeners(new AxisChangeEvent(this));
---
>         fireChangeEvent();
477c477
<         notifyListeners(new AxisChangeEvent(this));
---
>         fireChangeEvent();
504c504
<         notifyListeners(new AxisChangeEvent(this));
---
>         fireChangeEvent();
531c531
<         notifyListeners(new AxisChangeEvent(this));
---
>         fireChangeEvent();
543c543
<                                 Rectangle2D dataArea, RectangleEdge edge) {
---
>             Rectangle2D dataArea, RectangleEdge edge) {
643,646c643,644
<     protected float[] calculateAnchorPoint(ValueTick tick,
<                                            double cursor,
<                                            Rectangle2D dataArea,
<                                            RectangleEdge edge) {
---
>     protected float[] calculateAnchorPoint(ValueTick tick, double cursor,
>             Rectangle2D dataArea, RectangleEdge edge) {
779,781c777,778
<     public AxisSpace reserveSpace(Graphics2D g2, Plot plot,
<                                   Rectangle2D plotArea,
<                                   RectangleEdge edge, AxisSpace space) {
---
>     public AxisSpace reserveSpace(Graphics2D g2, Plot plot, 
>             Rectangle2D plotArea, RectangleEdge edge, AxisSpace space) {
818,819d814
<         double labelHeight = 0.0;
<         double labelWidth = 0.0;
821c816
<             labelHeight = labelEnclosure.getHeight();
---
>             double labelHeight = labelEnclosure.getHeight();
825c820
<             labelWidth = labelEnclosure.getWidth();
---
>             double labelWidth = labelEnclosure.getWidth();
844,847c839,840
<     protected double findMaximumTickLabelHeight(List ticks,
<                                                 Graphics2D g2,
<                                                 Rectangle2D drawArea,
<                                                 boolean vertical) {
---
>     protected double findMaximumTickLabelHeight(List ticks, Graphics2D g2,
>             Rectangle2D drawArea, boolean vertical) {
887,890c880,881
<     protected double findMaximumTickLabelWidth(List ticks,
<                                                Graphics2D g2,
<                                                Rectangle2D drawArea,
<                                                boolean vertical) {
---
>     protected double findMaximumTickLabelWidth(List ticks, Graphics2D g2,
>             Rectangle2D drawArea, boolean vertical) {
943d933
< 
946c936
<             notifyListeners(new AxisChangeEvent(this));
---
>             fireChangeEvent();
948d937
< 
992c981
<                 notifyListeners(new AxisChangeEvent(this));
---
>                 fireChangeEvent();
1042c1031
<                 notifyListeners(new AxisChangeEvent(this));
---
>                 fireChangeEvent();
1074c1063
<         notifyListeners(new AxisChangeEvent(this));
---
>         fireChangeEvent();
1107c1096
<         notifyListeners(new AxisChangeEvent(this));
---
>         fireChangeEvent();
1140c1129
<         notifyListeners(new AxisChangeEvent(this));
---
>         fireChangeEvent();
1166c1155
<         notifyListeners(new AxisChangeEvent(this));
---
>         fireChangeEvent();
1271c1260
<             notifyListeners(new AxisChangeEvent(this));
---
>             fireChangeEvent();
1384c1373
<                 notifyListeners(new AxisChangeEvent(this));
---
>                 fireChangeEvent();
1414c1403
<         notifyListeners(new AxisChangeEvent(this));
---
>         fireChangeEvent();
1442c1431
<         notifyListeners(new AxisChangeEvent(this));
---
>         fireChangeEvent();
1491,1493c1480,1481
<     public abstract double java2DToValue(double java2DValue,
<                                          Rectangle2D area,
<                                          RectangleEdge edge);
---
>     public abstract double java2DToValue(double java2DValue, Rectangle2D area, 
>             RectangleEdge edge);
1510d1497
< 
1515d1501
< 
1596c1582
<         Range adjusted = null;
---
>         Range adjusted;
1616c1602
<         Range range = getRange();
---
>         Range r = getRange();
1619,1620c1605,1606
<         double lower = range.getLowerBound() + adj;
<         double upper = range.getUpperBound() + adj;
---
>         double lower = r.getLowerBound() + adj;
>         double upper = r.getUpperBound() + adj;
diff -r jfreechart-1.0.15/src/org/jfree/chart/ChartFactory.java jfreechart-1.0.16/src/org/jfree/chart/ChartFactory.java
316a317,333
>      *
>      * @return A pie chart.
>      * 
>      * @since 1.0.16
>      */
>     public static JFreeChart createPieChart(String title, PieDataset dataset) {
>         return createPieChart(title, dataset, true, true, false);
>     }
>     
>     /**
>      * Creates a pie chart with default settings.
>      * <P>
>      * The chart object returned by this method uses a {@link PiePlot} instance
>      * as the plot.
>      *
>      * @param title  the chart title (<code>null</code> permitted).
>      * @param dataset  the dataset for the chart (<code>null</code> permitted).
724a742,758
>      *
>      * @return A pie chart.
>      * 
>      * @since 1.0.16
>      */
>     public static JFreeChart createPieChart3D(String title,
>             PieDataset dataset) {
>         return createPieChart3D(title, dataset, true, true, false);
>     }
>     
>     /**
>      * Creates a 3D pie chart using the specified dataset.  The chart object
>      * returned by this method uses a {@link PiePlot3D} instance as the
>      * plot.
>      *
>      * @param title  the chart title (<code>null</code> permitted).
>      * @param dataset  the dataset for the chart (<code>null</code> permitted).
803a838,862
>      * Creates a bar chart with a vertical orientation.  The chart object
>      * returned by this method uses a {@link CategoryPlot} instance as the
>      * plot, with a {@link CategoryAxis} for the domain axis, a
>      * {@link NumberAxis} as the range axis, and a {@link BarRenderer} as the
>      * renderer.
>      *
>      * @param title  the chart title (<code>null</code> permitted).
>      * @param categoryAxisLabel  the label for the category axis
>      *                           (<code>null</code> permitted).
>      * @param valueAxisLabel  the label for the value axis
>      *                        (<code>null</code> permitted).
>      * @param dataset  the dataset for the chart (<code>null</code> permitted).
>      *
>      * @return A bar chart.
>      * 
>      * @since 1.0.16
>      */
>     public static JFreeChart createBarChart(String title,
>             String categoryAxisLabel, String valueAxisLabel,
>             CategoryDataset dataset) {
>         return createBarChart(title, categoryAxisLabel, valueAxisLabel, dataset,
>                 PlotOrientation.VERTICAL, true, true, false);
>     }
>  
>     /**
880a940,964
>      *
>      * @return A stacked bar chart.
>      * 
>      * @since 1.0.16
>      */
>     public static JFreeChart createStackedBarChart(String title,
>             String domainAxisLabel, String rangeAxisLabel,
>             CategoryDataset dataset) {
>         return createStackedBarChart(title, domainAxisLabel, rangeAxisLabel,
>                 dataset, PlotOrientation.VERTICAL, true, true, false);
>     }
>     
>     /**
>      * Creates a stacked bar chart with default settings.  The chart object
>      * returned by this method uses a {@link CategoryPlot} instance as the
>      * plot, with a {@link CategoryAxis} for the domain axis, a
>      * {@link NumberAxis} as the range axis, and a {@link StackedBarRenderer}
>      * as the renderer.
>      *
>      * @param title  the chart title (<code>null</code> permitted).
>      * @param domainAxisLabel  the label for the category axis
>      *                         (<code>null</code> permitted).
>      * @param rangeAxisLabel  the label for the value axis
>      *                        (<code>null</code> permitted).
>      * @param dataset  the dataset for the chart (<code>null</code> permitted).
930a1015,1038
>      *
>      * @return A bar chart with a 3D effect.
>      * 
>      * @since 1.0.16
>      */
>     public static JFreeChart createBarChart3D(String title,
>             String categoryAxisLabel, String valueAxisLabel,
>             CategoryDataset dataset) {
>         return createBarChart3D(title, categoryAxisLabel, valueAxisLabel,
>                 dataset, PlotOrientation.VERTICAL, true, true, false);
>     }
>     
>     /**
>      * Creates a bar chart with a 3D effect. The chart object returned by this
>      * method uses a {@link CategoryPlot} instance as the plot, with a
>      * {@link CategoryAxis3D} for the domain axis, a {@link NumberAxis3D} as
>      * the range axis, and a {@link BarRenderer3D} as the renderer.
>      *
>      * @param title  the chart title (<code>null</code> permitted).
>      * @param categoryAxisLabel  the label for the category axis
>      *                           (<code>null</code> permitted).
>      * @param valueAxisLabel  the label for the value axis (<code>null</code>
>      *                        permitted).
>      * @param dataset  the dataset for the chart (<code>null</code> permitted).
988a1097,1121
>      *
>      * @return A stacked bar chart with a 3D effect.
>      * 
>      * @since 1.0.16
>      */
>     public static JFreeChart createStackedBarChart3D(String title,
>             String categoryAxisLabel, String valueAxisLabel,
>             CategoryDataset dataset) {
>         return createStackedBarChart3D(title, categoryAxisLabel, valueAxisLabel,
>                 dataset, PlotOrientation.VERTICAL, true, true, false);
>     }
>     
>     /**
>      * Creates a stacked bar chart with a 3D effect and default settings. The
>      * chart object returned by this method uses a {@link CategoryPlot}
>      * instance as the plot, with a {@link CategoryAxis3D} for the domain axis,
>      * a {@link NumberAxis3D} as the range axis, and a
>      * {@link StackedBarRenderer3D} as the renderer.
>      *
>      * @param title  the chart title (<code>null</code> permitted).
>      * @param categoryAxisLabel  the label for the category axis
>      *                           (<code>null</code> permitted).
>      * @param valueAxisLabel  the label for the value axis (<code>null</code>
>      *                        permitted).
>      * @param dataset  the dataset for the chart (<code>null</code> permitted).
1046a1180,1203
>      *
>      * @return An area chart.
>      * 
>      * @since 1.0.16
>      */
>     public static JFreeChart createAreaChart(String title,
>             String categoryAxisLabel, String valueAxisLabel,
>             CategoryDataset dataset) {
>         return createAreaChart(title, categoryAxisLabel, valueAxisLabel,
>                 dataset, PlotOrientation.VERTICAL, true, true, false);
>     }
>             
>     /**
>      * Creates an area chart with default settings.  The chart object returned
>      * by this method uses a {@link CategoryPlot} instance as the plot, with a
>      * {@link CategoryAxis} for the domain axis, a {@link NumberAxis} as the
>      * range axis, and an {@link AreaRenderer} as the renderer.
>      *
>      * @param title  the chart title (<code>null</code> permitted).
>      * @param categoryAxisLabel  the label for the category axis
>      *                           (<code>null</code> permitted).
>      * @param valueAxisLabel  the label for the value axis (<code>null</code>
>      *                        permitted).
>      * @param dataset  the dataset for the chart (<code>null</code> permitted).
1098a1256,1280
>      *
>      * @return A stacked area chart.
>      * 
>      * @since 1.0.16
>      */
>     public static JFreeChart createStackedAreaChart(String title,
>             String categoryAxisLabel, String valueAxisLabel,
>             CategoryDataset dataset) {
>         return createStackedAreaChart(title, categoryAxisLabel, valueAxisLabel,
>                 dataset, PlotOrientation.VERTICAL, true, true, false);
>     }
>     
>     /**
>      * Creates a stacked area chart with default settings.  The chart object
>      * returned by this method uses a {@link CategoryPlot} instance as the
>      * plot, with a {@link CategoryAxis} for the domain axis, a
>      * {@link NumberAxis} as the range axis, and a {@link StackedAreaRenderer}
>      * as the renderer.
>      *
>      * @param title  the chart title (<code>null</code> permitted).
>      * @param categoryAxisLabel  the label for the category axis
>      *                           (<code>null</code> permitted).
>      * @param valueAxisLabel  the label for the value axis (<code>null</code>
>      *                        permitted).
>      * @param dataset  the dataset for the chart (<code>null</code> permitted).
1148a1331,1354
>      *
>      * @return A line chart.
>      * 
>      * @since 1.0.16
>      */
>     public static JFreeChart createLineChart(String title,
>             String categoryAxisLabel, String valueAxisLabel,
>             CategoryDataset dataset) {
>         return createLineChart(title, categoryAxisLabel, valueAxisLabel,
>                 dataset, PlotOrientation.VERTICAL, true, true, false);
>     }
>     
>     /**
>      * Creates a line chart with default settings.  The chart object returned
>      * by this method uses a {@link CategoryPlot} instance as the plot, with a
>      * {@link CategoryAxis} for the domain axis, a {@link NumberAxis} as the
>      * range axis, and a {@link LineAndShapeRenderer} as the renderer.
>      *
>      * @param title  the chart title (<code>null</code> permitted).
>      * @param categoryAxisLabel  the label for the category axis
>      *                           (<code>null</code> permitted).
>      * @param valueAxisLabel  the label for the value axis (<code>null</code>
>      *                        permitted).
>      * @param dataset  the dataset for the chart (<code>null</code> permitted).
1196a1403,1426
>      *
>      * @return A line chart.
>      * 
>      * @since 1.0.16
>      */
>     public static JFreeChart createLineChart3D(String title,
>             String categoryAxisLabel, String valueAxisLabel,
>             CategoryDataset dataset) {
>         return createLineChart3D(title, categoryAxisLabel, valueAxisLabel,
>                 dataset, PlotOrientation.VERTICAL, true, true, false);
>     }    
>         
>     /**
>      * Creates a line chart with default settings. The chart object returned by
>      * this method uses a {@link CategoryPlot} instance as the plot, with a
>      * {@link CategoryAxis3D} for the domain axis, a {@link NumberAxis3D} as
>      * the range axis, and a {@link LineRenderer3D} as the renderer.
>      *
>      * @param title  the chart title (<code>null</code> permitted).
>      * @param categoryAxisLabel  the label for the category axis
>      *                           (<code>null</code> permitted).
>      * @param valueAxisLabel  the label for the value axis (<code>null</code>
>      *                        permitted).
>      * @param dataset  the dataset for the chart (<code>null</code> permitted).
1245a1476,1500
>      *
>      * @return A Gantt chart.
>      * 
>      * @since 1.0.16
>      */
>     public static JFreeChart createGanttChart(String title,
>             String categoryAxisLabel, String dateAxisLabel,
>             IntervalCategoryDataset dataset) {
>         return createGanttChart(title, categoryAxisLabel, dateAxisLabel,
>                 dataset, true, true, false);
>     }
>     
>     /**
>      * Creates a Gantt chart using the supplied attributes plus default values
>      * where required.  The chart object returned by this method uses a
>      * {@link CategoryPlot} instance as the plot, with a {@link CategoryAxis}
>      * for the domain axis, a {@link DateAxis} as the range axis, and a
>      * {@link GanttRenderer} as the renderer.
>      *
>      * @param title  the chart title (<code>null</code> permitted).
>      * @param categoryAxisLabel  the label for the category axis
>      *                           (<code>null</code> permitted).
>      * @param dateAxisLabel  the label for the date axis
>      *                       (<code>null</code> permitted).
>      * @param dataset  the dataset for the chart (<code>null</code> permitted).
1381a1637,1658
>     
>     /**
>      * Creates a scatter plot with default settings.  The chart object
>      * returned by this method uses an {@link XYPlot} instance as the plot,
>      * with a {@link NumberAxis} for the domain axis, a  {@link NumberAxis}
>      * as the range axis, and an {@link XYLineAndShapeRenderer} as the
>      * renderer.
>      *
>      * @param title  the chart title (<code>null</code> permitted).
>      * @param xAxisLabel  a label for the X-axis (<code>null</code> permitted).
>      * @param yAxisLabel  a label for the Y-axis (<code>null</code> permitted).
>      * @param dataset  the dataset for the chart (<code>null</code> permitted).
>      *
>      * @return A scatter plot.
>      * 
>      * @since 1.0.16
>      */
>     public static JFreeChart createScatterPlot(String title, String xAxisLabel,
>             String yAxisLabel, XYDataset dataset) {
>         return createScatterPlot(title, xAxisLabel, yAxisLabel, dataset,
>                 PlotOrientation.VERTICAL, true, true, false);
>     }
1448a1726,1749
>      *
>      * @return An XY bar chart.
>      * 
>      * @since 1.0.16
>      */
>     public static JFreeChart createXYBarChart(String title, String xAxisLabel,
>             boolean dateAxis, String yAxisLabel, IntervalXYDataset dataset) {
>         return createXYBarChart(title, xAxisLabel, dateAxis, yAxisLabel,
>                 dataset, PlotOrientation.VERTICAL, true, true, false);
>     }
>     
>     /**
>      * Creates and returns a default instance of an XY bar chart.
>      * <P>
>      * The chart object returned by this method uses an {@link XYPlot} instance
>      * as the plot, with a {@link DateAxis} for the domain axis, a
>      * {@link NumberAxis} as the range axis, and a {@link XYBarRenderer} as the
>      * renderer.
>      *
>      * @param title  the chart title (<code>null</code> permitted).
>      * @param xAxisLabel  a label for the X-axis (<code>null</code> permitted).
>      * @param dateAxis  make the domain axis display dates?
>      * @param yAxisLabel  a label for the Y-axis (<code>null</code> permitted).
>      * @param dataset  the dataset for the chart (<code>null</code> permitted).
1510a1812,1834
>      *
>      * @return An XY area chart.
>      * 
>      * @since 1.0.16
>      */
>     public static JFreeChart createXYAreaChart(String title,String xAxisLabel,
>             String yAxisLabel, XYDataset dataset) {
>         return createXYAreaChart(title, xAxisLabel, yAxisLabel, dataset, 
>                 PlotOrientation.VERTICAL, true, true, false);
>     }
>     
>     /**
>      * Creates an area chart using an {@link XYDataset}.
>      * <P>
>      * The chart object returned by this method uses an {@link XYPlot} instance
>      * as the plot, with a {@link NumberAxis} for the domain axis, a
>      * {@link NumberAxis} as the range axis, and a {@link XYAreaRenderer} as
>      * the renderer.
>      *
>      * @param title  the chart title (<code>null</code> permitted).
>      * @param xAxisLabel  a label for the X-axis (<code>null</code> permitted).
>      * @param yAxisLabel  a label for the Y-axis (<code>null</code> permitted).
>      * @param dataset  the dataset for the chart (<code>null</code> permitted).
1559a1884,1904
>      *
>      * @return A stacked XY area chart.
>      * 
>      * @since 1.0.16
>      */
>     public static JFreeChart createStackedXYAreaChart(String title,
>             String xAxisLabel, String yAxisLabel, TableXYDataset dataset) {
>         return createStackedXYAreaChart(title, xAxisLabel, yAxisLabel,
>                 dataset, PlotOrientation.VERTICAL, true, true, false);
>     }
>     
>     /**
>      * Creates a stacked XY area plot.  The chart object returned by this
>      * method uses an {@link XYPlot} instance as the plot, with a
>      * {@link NumberAxis} for the domain axis, a {@link NumberAxis} as the
>      * range axis, and a {@link StackedXYAreaRenderer2} as the renderer.
>      *
>      * @param title  the chart title (<code>null</code> permitted).
>      * @param xAxisLabel  a label for the X-axis (<code>null</code> permitted).
>      * @param yAxisLabel  a label for the Y-axis (<code>null</code> permitted).
>      * @param dataset  the dataset for the chart (<code>null</code> permitted).
1610a1956,1972
>      *
>      * @return The chart.
>      */
>     public static JFreeChart createXYLineChart(String title,
>             String xAxisLabel, String yAxisLabel, XYDataset dataset) {
>         return createXYLineChart(title, xAxisLabel, yAxisLabel, dataset,
>                 PlotOrientation.VERTICAL, true, true, false);
>     }
> 
>     /**
>      * Creates a line chart (based on an {@link XYDataset}) with default
>      * settings.
>      *
>      * @param title  the chart title (<code>null</code> permitted).
>      * @param xAxisLabel  a label for the X-axis (<code>null</code> permitted).
>      * @param yAxisLabel  a label for the Y-axis (<code>null</code> permitted).
>      * @param dataset  the dataset for the chart (<code>null</code> permitted).
1650a2013,2030
>      *
>      * @return A chart.
>      * 
>      * @since 1.0.16
>      */
>     public static JFreeChart createXYStepChart(String title, String xAxisLabel,
>             String yAxisLabel, XYDataset dataset) {
>         return createXYStepChart(title, xAxisLabel, yAxisLabel, dataset,
>                 PlotOrientation.VERTICAL, true, true, false);
>     }
>     
>     /**
>      * Creates a stepped XY plot with default settings.
>      *
>      * @param title  the chart title (<code>null</code> permitted).
>      * @param xAxisLabel  a label for the X-axis (<code>null</code> permitted).
>      * @param yAxisLabel  a label for the Y-axis (<code>null</code> permitted).
>      * @param dataset  the dataset for the chart (<code>null</code> permitted).
1698a2079,2096
>      *
>      * @return A chart.
>      * 
>      * @since 1.0.16
>      */
>     public static JFreeChart createXYStepAreaChart(String title,
>             String xAxisLabel, String yAxisLabel, XYDataset dataset) {
>         return createXYStepAreaChart(title, xAxisLabel, yAxisLabel, dataset,
>                 PlotOrientation.VERTICAL, true, true, false);   
>     }
>  
>     /**
>      * Creates a filled stepped XY plot with default settings.
>      *
>      * @param title  the chart title (<code>null</code> permitted).
>      * @param xAxisLabel  a label for the X-axis (<code>null</code> permitted).
>      * @param yAxisLabel  a label for the Y-axis (<code>null</code> permitted).
>      * @param dataset  the dataset for the chart (<code>null</code> permitted).
1755a2154,2179
>      *
>      * @return A time series chart.
>      * 
>      * @since 1.0.16
>      */
>     public static JFreeChart createTimeSeriesChart(String title, 
>             String timeAxisLabel, String valueAxisLabel, XYDataset dataset) {
>         return createTimeSeriesChart(title, timeAxisLabel, valueAxisLabel, 
>                 dataset, true, true, false);
>     }
>     
>     /**
>      * Creates and returns a time series chart.  A time series chart is an
>      * {@link XYPlot} with a {@link DateAxis} for the x-axis and a
>      * {@link NumberAxis} for the y-axis.  The default renderer is an
>      * {@link XYLineAndShapeRenderer}.
>      * <P>
>      * A convenient dataset to use with this chart is a
>      * {@link org.jfree.data.time.TimeSeriesCollection}.
>      *
>      * @param title  the chart title (<code>null</code> permitted).
>      * @param timeAxisLabel  a label for the time axis (<code>null</code>
>      *                       permitted).
>      * @param valueAxisLabel  a label for the value axis (<code>null</code>
>      *                        permitted).
>      * @param dataset  the dataset for the chart (<code>null</code> permitted).
1888a2313,2333
>     /**
>      * Creates a bubble chart with default settings.  The chart is composed of
>      * an {@link XYPlot}, with a {@link NumberAxis} for the domain axis,
>      * a {@link NumberAxis} for the range axis, and an {@link XYBubbleRenderer}
>      * to draw the data items.
>      *
>      * @param title  the chart title (<code>null</code> permitted).
>      * @param xAxisLabel  a label for the X-axis (<code>null</code> permitted).
>      * @param yAxisLabel  a label for the Y-axis (<code>null</code> permitted).
>      * @param dataset  the dataset for the chart (<code>null</code> permitted).
>      *
>      * @return A bubble chart.
>      * 
>      * @since 1.0.16
>      */
>     public static JFreeChart createBubbleChart(String title, String xAxisLabel,
>             String yAxisLabel, XYZDataset dataset) {
>         return createBubbleChart(title, xAxisLabel, yAxisLabel, dataset,
>                 PlotOrientation.VERTICAL, true, true, false);
>     }
>     
diff -r jfreechart-1.0.15/src/org/jfree/chart/ChartPanel.java jfreechart-1.0.16/src/org/jfree/chart/ChartPanel.java
170a171,172
>  * 12-Sep-2013 : Provide auto-detection for JFreeSVG and OrsonPDF 
>  *               libraries (no compile time dependencies) (DG);
206a209
> import java.io.BufferedWriter;
207a211
> import java.io.FileWriter;
211a216,218
> import java.lang.reflect.Constructor;
> import java.lang.reflect.InvocationTargetException;
> import java.lang.reflect.Method;
225a233
> import javax.swing.filechooser.FileNameExtensionFilter;
246d253
< import org.jfree.ui.ExtensionFileFilter;
303a311,319
>     /** Action command to save as PNG. */
>     private static final String SAVE_AS_PNG_COMMAND = "SAVE_AS_PNG";
>     
>     /** Action command to save as SVG. */
>     private static final String SAVE_AS_SVG_COMMAND = "SAVE_AS_SVG";
>     
>     /** Action command to save as PDF. */
>     private static final String SAVE_AS_PDF_COMMAND = "SAVE_AS_PDF";
>     
1373a1390
>     @Override
1401a1419
>     @Override
1403d1420
< 
1418d1434
< 
1520a1537
>     @Override
1661a1679
>     @Override
1676a1695
>     @Override
1685a1705
>     @Override
1706c1726
<         else if (command.equals(SAVE_COMMAND)) {
---
>         else if (command.equals(SAVE_AS_PNG_COMMAND)) {
1711c1731,1740
<                 e.printStackTrace();
---
>                 JOptionPane.showMessageDialog(this, "I/O error occurred.", 
>                         "Save As PNG", JOptionPane.WARNING_MESSAGE);
>             }
>         }
>         else if (command.equals(SAVE_AS_SVG_COMMAND)) {
>             try {
>                 saveAsSVG(null);
>             } catch (IOException e) {
>                 JOptionPane.showMessageDialog(this, "I/O error occurred.", 
>                         "Save As SVG", JOptionPane.WARNING_MESSAGE);
1713a1743,1745
>         else if (command.equals(SAVE_AS_PDF_COMMAND)) {
>             saveAsPDF(null);
>         }
1753a1786
>     @Override
1777a1811
>     @Override
1796a1831
>     @Override
1860a1896
>     @Override
1962a1999
>     @Override
2059a2097
>     @Override
2097a2136
>     @Override
2673d2711
< 
2676,2677c2714,2715
<         ExtensionFileFilter filter = new ExtensionFileFilter(
<                 localizationResources.getString("PNG_Image_Files"), ".png");
---
>         FileNameExtensionFilter filter = new FileNameExtensionFilter(
>                     localizationResources.getString("PNG_Image_Files"), "png");
2678a2717
>         fileChooser.setFileFilter(filter);
2690a2730,2787
>     }
>     
>     /**
>      * Saves the chart in SVG format (a filechooser will be displayed so that
>      * the user can specify the filename).  Note that this method only works
>      * if the JFreeSVG library is on the classpath...if this library is not 
>      * present, the method will fail.
>      */
>     private void saveAsSVG(File f) throws IOException {
>         File file = f;
>         if (file == null) {
>             JFileChooser fileChooser = new JFileChooser();
>             fileChooser.setCurrentDirectory(this.defaultDirectoryForSaveAs);
>             FileNameExtensionFilter filter = new FileNameExtensionFilter(
>                     localizationResources.getString("SVG_Files"), "svg");
>             fileChooser.addChoosableFileFilter(filter);
>             fileChooser.setFileFilter(filter);
> 
>             int option = fileChooser.showSaveDialog(this);
>             if (option == JFileChooser.APPROVE_OPTION) {
>                 String filename = fileChooser.getSelectedFile().getPath();
>                 if (isEnforceFileExtensions()) {
>                     if (!filename.endsWith(".svg")) {
>                         filename = filename + ".svg";
>                     }
>                 }
>                 file = new File(filename);
>                 if (file.exists()) {
>                     String fileExists = localizationResources.getString(
>                             "FILE_EXISTS_CONFIRM_OVERWRITE");
>                     int response = JOptionPane.showConfirmDialog(this, 
>                             fileExists, "Save As SVG", 
>                             JOptionPane.OK_CANCEL_OPTION);
>                     if (response == JOptionPane.CANCEL_OPTION) {
>                         file = null;
>                     }
>                 }
>             }
>         }
>         
>         if (file != null) {
>             // use reflection to get the SVG string
>             String svg = generateSVG(getWidth(), getHeight());
>             BufferedWriter writer = null;
>             try {
>                 writer = new BufferedWriter(new FileWriter(file));
>                 writer.write("<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\n");
>                 writer.write(svg + "\n");
>                 writer.flush();
>             } finally {
>                 try {
>                     if (writer != null) {
>                         writer.close();
>                     }
>                 } catch (IOException ex) {
>                     throw new RuntimeException(ex);
>                 }
>             } 
2691a2789,2956
>         }
>     }
>     
>     /**
>      * Generates a string containing a rendering of the chart in SVG format.
>      * This feature is only supported if the JFreeSVG library is included on 
>      * the classpath.
>      * 
>      * @return A string containing an SVG element for the current chart, or 
>      *     <code>null</code> if there is a problem with the method invocation
>      *     by reflection.
>      */
>     private String generateSVG(int width, int height) {
>         Graphics2D g2 = createSVGGraphics2D(width, height);
>         if (g2 == null) {
>             throw new IllegalStateException("JFreeSVG library is not present.");
>         }
>         // we suppress shadow generation, because SVG is a vector format and
>         // the shadow effect is applied via bitmap effects...
>         g2.setRenderingHint(JFreeChart.KEY_SUPPRESS_SHADOW_GENERATION, true);
>         String svg = null;
>         Rectangle2D drawArea = new Rectangle2D.Double(0, 0, width, height);
>         this.chart.draw(g2, drawArea);
>         try {
>             Method m = g2.getClass().getMethod("getSVGElement");
>             svg = (String) m.invoke(g2);
>         } catch (NoSuchMethodException e) {
>             // null will be returned
>         } catch (SecurityException e) {
>             // null will be returned
>         } catch (IllegalAccessException e) {
>             // null will be returned
>         } catch (IllegalArgumentException e) {
>             // null will be returned
>         } catch (InvocationTargetException e) {
>             // null will be returned
>         }
>         return svg;
>     }
> 
>     private Graphics2D createSVGGraphics2D(int w, int h) {
>         try {
>             Class svgGraphics2d = Class.forName("org.jfree.graphics2d.svg.SVGGraphics2D");
>             Constructor ctor = svgGraphics2d.getConstructor(int.class, int.class);
>             return (Graphics2D) ctor.newInstance(w, h);
>         } catch (ClassNotFoundException ex) {
>             return null;
>         } catch (NoSuchMethodException ex) {
>             return null;
>         } catch (SecurityException ex) {
>             return null;
>         } catch (InstantiationException ex) {
>             return null;
>         } catch (IllegalAccessException ex) {
>             return null;
>         } catch (IllegalArgumentException ex) {
>             return null;
>         } catch (InvocationTargetException ex) {
>             return null;
>         }
>     }
> 
>     /**
>      * Saves the chart in PDF format (a filechooser will be displayed so that
>      * the user can specify the filename).  Note that this method only works
>      * if the OrsonPDF library is on the classpath...if this library is not
>      * present, the method will fail.
>      */
>     private void saveAsPDF(File f) {
>         File file = f;
>         if (file == null) {
>             JFileChooser fileChooser = new JFileChooser();
>             fileChooser.setCurrentDirectory(this.defaultDirectoryForSaveAs);
>             FileNameExtensionFilter filter = new FileNameExtensionFilter(
>                     localizationResources.getString("PDF_Files"), "pdf");
>             fileChooser.addChoosableFileFilter(filter);
>             fileChooser.setFileFilter(filter);
> 
>             int option = fileChooser.showSaveDialog(this);
>             if (option == JFileChooser.APPROVE_OPTION) {
>                 String filename = fileChooser.getSelectedFile().getPath();
>                 if (isEnforceFileExtensions()) {
>                     if (!filename.endsWith(".pdf")) {
>                         filename = filename + ".pdf";
>                     }
>                 }
>                 file = new File(filename);
>                 if (file.exists()) {
>                     String fileExists = localizationResources.getString(
>                             "FILE_EXISTS_CONFIRM_OVERWRITE");
>                     int response = JOptionPane.showConfirmDialog(this, 
>                             fileExists, "Save As PDF", 
>                             JOptionPane.OK_CANCEL_OPTION);
>                     if (response == JOptionPane.CANCEL_OPTION) {
>                         file = null;
>                     }
>                 }
>             }
>         }
>         
>         if (file != null) {
>             writeAsPDF(file, getWidth(), getHeight());
>         }
>     }
> 
>     /**
>      * Returns <code>true</code> if OrsonPDF is on the classpath, and 
>      * <code>false</code> otherwise.  The OrsonPDF library can be found at
>      * http://www.object-refinery.com/pdf/
>      * 
>      * @return A boolean.
>      */
>     private boolean isOrsonPDFAvailable() {
>         Class pdfDocumentClass = null;
>         try {
>             pdfDocumentClass = Class.forName("com.orsonpdf.PDFDocument");
>         } catch (ClassNotFoundException e) {
>             // pdfDocument class will be null so the function will return false
>         }
>         return (pdfDocumentClass != null);
>     }
>     
>     /**
>      * Writes the current chart to the specified file in PDF format.  This 
>      * will only work when the OrsonPDF library is found on the classpath.
>      * Reflection is used to ensure there is no compile-time dependency on
>      * OrsonPDF (which is non-free software).
>      * 
>      * @param file  the output file (<code>null</code> not permitted).
>      * @param w  the chart width.
>      * @param h  the chart height.
>      */
>     private void writeAsPDF(File file, int w, int h) {
>         if (!isOrsonPDFAvailable()) {
>             throw new IllegalStateException(
>                     "OrsonPDF is not present on the classpath.");
>         }
>         ParamChecks.nullNotPermitted(file, "file");
>         try {
>             Class pdfDocClass = Class.forName("com.orsonpdf.PDFDocument");
>             Object pdfDoc = pdfDocClass.newInstance();
>             Method m = pdfDocClass.getMethod("createPage", Rectangle2D.class);
>             Rectangle2D rect = new Rectangle(w, h);
>             Object page = m.invoke(pdfDoc, rect);
>             Method m2 = page.getClass().getMethod("getGraphics2D");
>             Graphics2D g2 = (Graphics2D) m2.invoke(page);
>             // we suppress shadow generation, because PDF is a vector format and
>             // the shadow effect is applied via bitmap effects...
>             g2.setRenderingHint(JFreeChart.KEY_SUPPRESS_SHADOW_GENERATION, true);
>             Rectangle2D drawArea = new Rectangle2D.Double(0, 0, w, h);
>             this.chart.draw(g2, drawArea);
>             Method m3 = pdfDocClass.getMethod("writeToFile", File.class);
>             m3.invoke(pdfDoc, file);
>         } catch (ClassNotFoundException ex) {
>             throw new RuntimeException(ex);
>         } catch (InstantiationException ex) {
>             throw new RuntimeException(ex);
>         } catch (IllegalAccessException ex) {
>             throw new RuntimeException(ex);
>         } catch (NoSuchMethodException ex) {
>             throw new RuntimeException(ex);
>         } catch (SecurityException ex) {
>             throw new RuntimeException(ex);
>         } catch (IllegalArgumentException ex) {
>             throw new RuntimeException(ex);
>         } catch (InvocationTargetException ex) {
>             throw new RuntimeException(ex);
>         }
2698d2962
< 
2713d2976
< 
2725a2989
>     @Override
2769a3034
>     @Override
2839,2843c3104,3123
<             JMenuItem saveItem = new JMenuItem(
<                     localizationResources.getString("Save_as..."));
<             saveItem.setActionCommand(SAVE_COMMAND);
<             saveItem.addActionListener(this);
<             result.add(saveItem);
---
>             JMenu saveSubMenu = new JMenu("Save as");
>             JMenuItem pngItem = new JMenuItem("PNG...");
>             pngItem.setActionCommand("SAVE_AS_PNG");
>             pngItem.addActionListener(this);
>             saveSubMenu.add(pngItem);
>             
>             if (createSVGGraphics2D(10, 10) != null) {
>                 JMenuItem svgItem = new JMenuItem("SVG...");
>                 svgItem.setActionCommand("SAVE_AS_SVG");
>                 svgItem.addActionListener(this);
>                 saveSubMenu.add(svgItem);                
>             }
>             
>             if (isOrsonPDFAvailable()) {
>                 JMenuItem pdfItem = new JMenuItem("PDF...");
>                 pdfItem.setActionCommand("SAVE_AS_PDF");
>                 pdfItem.addActionListener(this);
>                 saveSubMenu.add(pdfItem);
>             }
>             result.add(saveSubMenu);
3013a3294
>     @Override
diff -r jfreechart-1.0.15/src/org/jfree/chart/demo/PieChartDemo1.java jfreechart-1.0.16/src/org/jfree/chart/demo/PieChartDemo1.java
30c30
<  * (C) Copyright 2003-2011, by Object Refinery Limited and Contributors.
---
>  * (C) Copyright 2003-2013, by Object Refinery Limited and Contributors.
43a44,51
> import java.awt.BasicStroke;
> import java.awt.Color;
> import java.awt.Dimension;
> import java.awt.Font;
> import java.awt.GradientPaint;
> import java.awt.Point;
> import java.awt.RadialGradientPaint;
> import java.awt.geom.Point2D;
50a59
> import org.jfree.chart.title.TextTitle;
53a63,65
> import org.jfree.ui.HorizontalAlignment;
> import org.jfree.ui.RectangleEdge;
> import org.jfree.ui.RectangleInsets;
82a95,96
>      * 
>      * Source: http://www.bbc.co.uk/news/business-15489523
88,93c102,105
<         dataset.setValue("One", new Double(43.2));
<         dataset.setValue("Two", new Double(10.0));
<         dataset.setValue("Three", new Double(27.5));
<         dataset.setValue("Four", new Double(17.5));
<         dataset.setValue("Five", new Double(11.0));
<         dataset.setValue("Six", new Double(19.4));
---
>         dataset.setValue("Samsung", new Double(27.8));
>         dataset.setValue("Others", new Double(55.3));
>         dataset.setValue("Nokia", new Double(16.8));
>         dataset.setValue("Apple", new Double(17.1));
107,111c119,123
<             "Pie Chart Demo 1",  // chart title
<             dataset,             // data
<             true,                // include legend
<             true,
<             false
---
>             "Smart Phones Manufactured / Q3 2011",  // chart title
>             dataset,            // data
>             false,              // no legend
>             true,               // tooltips
>             false               // no URL generation
113a126,135
>         // set a custom background for the chart
>         chart.setBackgroundPaint(new GradientPaint(new Point(0, 0), 
>                 new Color(20, 20, 20), new Point(400, 200), Color.DARK_GRAY));
> 
>         // customise the title position and font
>         TextTitle t = chart.getTitle();
>         t.setHorizontalAlignment(HorizontalAlignment.LEFT);
>         t.setPaint(new Color(240, 240, 240));
>         t.setFont(new Font("Arial", Font.BOLD, 26));
> 
115,116c137,164
<         plot.setSectionOutlinesVisible(false);
<         plot.setNoDataMessage("No data available");
---
>         plot.setBackgroundPaint(null);
>         plot.setInteriorGap(0.04);
>         plot.setOutlineVisible(false);
> 
>         // use gradients and white borders for the section colours
>         plot.setSectionPaint("Others", createGradientPaint(new Color(200, 200, 255), Color.BLUE));
>         plot.setSectionPaint("Samsung", createGradientPaint(new Color(255, 200, 200), Color.RED));
>         plot.setSectionPaint("Apple", createGradientPaint(new Color(200, 255, 200), Color.GREEN));
>         plot.setSectionPaint("Nokia", createGradientPaint(new Color(200, 255, 200), Color.YELLOW));
>         plot.setBaseSectionOutlinePaint(Color.WHITE);
>         plot.setSectionOutlinesVisible(true);
>         plot.setBaseSectionOutlineStroke(new BasicStroke(2.0f));
> 
>         // customise the section label appearance
>         plot.setLabelFont(new Font("Courier New", Font.BOLD, 20));
>         plot.setLabelLinkPaint(Color.WHITE);
>         plot.setLabelLinkStroke(new BasicStroke(2.0f));
>         plot.setLabelOutlineStroke(null);
>         plot.setLabelPaint(Color.WHITE);
>         plot.setLabelBackgroundPaint(null);
>         
>         // add a subtitle giving the data source
>         TextTitle source = new TextTitle("Source: http://www.bbc.co.uk/news/business-15489523", 
>                 new Font("Courier New", Font.PLAIN, 12));
>         source.setPaint(Color.WHITE);
>         source.setPosition(RectangleEdge.BOTTOM);
>         source.setHorizontalAlignment(HorizontalAlignment.RIGHT);
>         chart.addSubtitle(source);
121a170,185
>      * A utility method for creating gradient paints.
>      * 
>      * @param c1  color 1.
>      * @param c2  color 2.
>      * 
>      * @return A radial gradient paint.
>      */
>     private static RadialGradientPaint createGradientPaint(Color c1, Color c2) {
>         Point2D center = new Point2D.Float(0, 0);
>         float radius = 200;
>         float[] dist = {0.0f, 1.0f};
>         return new RadialGradientPaint(center, radius, dist,
>                 new Color[] {c1, c2});
>     }
> 
>     /**
127a192
>         chart.setPadding(new RectangleInsets(4, 8, 2, 2));
129a195
>         panel.setPreferredSize(new Dimension(600, 300));
148c214
<         PieChartDemo1 demo = new PieChartDemo1("Pie Chart Demo 1");
---
>         PieChartDemo1 demo = new PieChartDemo1("JFreeChart: Pie Chart Demo 1");
154a221
> 
diff -r jfreechart-1.0.15/src/org/jfree/chart/JFreeChart.java jfreechart-1.0.16/src/org/jfree/chart/JFreeChart.java
274a275,289
>      * The key for a rendering hint that can suppress the generation of a 
>      * shadow effect when drawing the chart.  The hint value must be a 
>      * Boolean.
>      * 
>      * @since 1.0.16
>      */
>     public static final RenderingHints.Key KEY_SUPPRESS_SHADOW_GENERATION
>             = new RenderingHints.Key(0) {
>         @Override
>         public boolean isCompatibleValue(Object val) {
>             return val instanceof Boolean;
>         }
>     };
>     
>     /**
diff -r jfreechart-1.0.15/src/org/jfree/chart/LocalizationBundle.properties jfreechart-1.0.16/src/org/jfree/chart/LocalizationBundle.properties
13a14
> FILE_EXISTS_CONFIRM_OVERWRITE=The file already exists, are you sure you want to overwrite it?
14a16
> PDF_Files=PDF Files
17d18
< Save_as...=Save as...
18a20,21
> Save_as...=Save as...
> SVG_Files=SVG Files
diff -r jfreechart-1.0.15/src/org/jfree/chart/plot/CategoryPlot.java jfreechart-1.0.16/src/org/jfree/chart/plot/CategoryPlot.java
181a182
>  * 12-Sep-2013 : Check for KEY_SUPPRESS_SHADOW_GENERATION rendering hint (DG);
215a217
> import org.jfree.chart.JFreeChart;
672a675
>     @Override
683a687
>     @Override
963c967
<         RectangleEdge result = null;
---
>         RectangleEdge result;
1462c1466
<         CategoryAxis axis = null;
---
>         CategoryAxis axis;
2185a2190
>     @Override
2212a2218
>     @Override
2243a2250
>     @Override
2265a2273
>     @Override
2282a2291
>     @Override
3508a3518
>     @Override
3608c3618,3620
<         if (this.shadowGenerator != null) {
---
>         boolean suppressShadow = Boolean.TRUE.equals(g2.getRenderingHint(
>                 JFreeChart.KEY_SUPPRESS_SHADOW_GENERATION));
>         if (this.shadowGenerator != null && !suppressShadow) {
3656c3668
<         if (this.shadowGenerator != null) {
---
>         if (this.shadowGenerator != null && !suppressShadow) {
3732a3745
>     @Override
3971c3984
<         boolean paintLine = false;
---
>         boolean paintLine;
4170c4183
<         Line2D line = null;
---
>         Line2D line;
4212c4225
<         Line2D line = null;
---
>         Line2D line;
4239a4253
>     @Override
4514a4529
>     @Override
4529a4545
>     @Override
4556a4573
>     @Override
4570a4588
>     @Override
4599a4618
>     @Override
4610a4630
>     @Override
4622a4643
>     @Override
4636a4658
>     @Override
4654a4677
>     @Override
4666a4690
>     @Override
4685a4710
>     @Override
4718a4744
>     @Override
4774a4801
>     @Override
4962a4990
>     @Override
diff -r jfreechart-1.0.15/src/org/jfree/chart/plot/CombinedDomainCategoryPlot.java jfreechart-1.0.16/src/org/jfree/chart/plot/CombinedDomainCategoryPlot.java
83a84
> import org.jfree.chart.util.ShadowGenerator;
504d504
< 
506d505
< 
512a512,529
>     }
> 
>     /**
>      * Sets the shadow generator for the plot (and all subplots) and sends
>      * a {@link PlotChangeEvent} to all registered listeners.
>      * 
>      * @param generator  the new generator (<code>null</code> permitted).
>      */
>     @Override
>     public void setShadowGenerator(ShadowGenerator generator) {
>         setNotify(false);
>         super.setShadowGenerator(generator);
>         Iterator iterator = this.subplots.iterator();
>         while (iterator.hasNext()) {
>             CategoryPlot plot = (CategoryPlot) iterator.next();
>             plot.setShadowGenerator(generator);
>         }
>         setNotify(true);
diff -r jfreechart-1.0.15/src/org/jfree/chart/plot/CombinedDomainXYPlot.java jfreechart-1.0.16/src/org/jfree/chart/plot/CombinedDomainXYPlot.java
115a116
> import org.jfree.chart.util.ShadowGenerator;
187a189,206
>     }
> 
>     /**
>      * Sets the shadow generator for the plot (and all subplots) and sends
>      * a {@link PlotChangeEvent} to all registered listeners.
>      * 
>      * @param generator  the new generator (<code>null</code> permitted).
>      */
>     @Override
>     public void setShadowGenerator(ShadowGenerator generator) {
>         setNotify(false);
>         super.setShadowGenerator(generator);
>         Iterator iterator = this.subplots.iterator();
>         while (iterator.hasNext()) {
>             XYPlot plot = (XYPlot) iterator.next();
>             plot.setShadowGenerator(generator);
>         }
>         setNotify(true);
diff -r jfreechart-1.0.15/src/org/jfree/chart/plot/CombinedRangeCategoryPlot.java jfreechart-1.0.16/src/org/jfree/chart/plot/CombinedRangeCategoryPlot.java
81a82
> import org.jfree.chart.util.ShadowGenerator;
392d392
< 
394d393
< 
399a399
>     }
400a401,416
>     /**
>      * Sets the shadow generator for the plot (and all subplots) and sends
>      * a {@link PlotChangeEvent} to all registered listeners.
>      * 
>      * @param generator  the new generator (<code>null</code> permitted).
>      */
>     @Override
>     public void setShadowGenerator(ShadowGenerator generator) {
>         setNotify(false);
>         super.setShadowGenerator(generator);
>         Iterator iterator = this.subplots.iterator();
>         while (iterator.hasNext()) {
>             CategoryPlot plot = (CategoryPlot) iterator.next();
>             plot.setShadowGenerator(generator);
>         }
>         setNotify(true);
diff -r jfreechart-1.0.15/src/org/jfree/chart/plot/CombinedRangeXYPlot.java jfreechart-1.0.16/src/org/jfree/chart/plot/CombinedRangeXYPlot.java
117a118
> import org.jfree.chart.util.ShadowGenerator;
588a590,607
>     }
> 
>     /**
>      * Sets the shadow generator for the plot (and all subplots) and sends
>      * a {@link PlotChangeEvent} to all registered listeners.
>      * 
>      * @param generator  the new generator (<code>null</code> permitted).
>      */
>     @Override
>     public void setShadowGenerator(ShadowGenerator generator) {
>         setNotify(false);
>         super.setShadowGenerator(generator);
>         Iterator iterator = this.subplots.iterator();
>         while (iterator.hasNext()) {
>             XYPlot plot = (XYPlot) iterator.next();
>             plot.setShadowGenerator(generator);
>         }
>         setNotify(true);
diff -r jfreechart-1.0.15/src/org/jfree/chart/plot/PiePlot.java jfreechart-1.0.16/src/org/jfree/chart/plot/PiePlot.java
171a172
>  * 12-Sep-2013 : Check for KEY_SUPPRESS_SHADOW_GENERATION rendering hint (DG);
184a186
> import java.awt.RadialGradientPaint;
199,200d200
< import java.lang.reflect.Constructor;
< import java.lang.reflect.Method;
205a206
> import org.jfree.chart.JFreeChart;
2397a2399
>     @Override
2421a2424,2425
>             boolean suppressShadow = Boolean.TRUE.equals(g2.getRenderingHint(
>                     JFreeChart.KEY_SUPPRESS_SHADOW_GENERATION));
2423c2427
<             if (this.shadowGenerator != null) {
---
>             if (this.shadowGenerator != null && !suppressShadow) {
2431,2432c2435,2437
<             if (this.shadowGenerator != null) {
<                 BufferedImage shadowImage = this.shadowGenerator.createDropShadow(dataImage);
---
>             if (this.shadowGenerator != null && !suppressShadow) {
>                 BufferedImage shadowImage 
>                         = this.shadowGenerator.createDropShadow(dataImage);
2470,2471c2475
<         double gapHorizontal = plotArea.getWidth() * (this.interiorGap
<                 + labelReserve) * 2.0;
---
>         double gapHorizontal = plotArea.getWidth() * labelReserve * 2.0;
2831,2832c2835
<         double marginX = plotArea.getX() + this.interiorGap
<                 * plotArea.getWidth();
---
>         double marginX = plotArea.getX();
2958c2961
<         double gap = hh * getInteriorGap();
---
>         double gap = 0.00; //hh * getInteriorGap();
2972a2976
>     @Override
3253,3275c3257,3266
<         // If using JDK 1.6 or later the passed Paint Object can be a RadialGradientPaint
<         // We need to adjust the radius and center for this object to match the Pie.
<         try {
<             Class c = Class.forName("java.awt.RadialGradientPaint");
<             Constructor cc = c.getConstructor(new Class[] {
<                     Point2D.class, float.class, float[].class, Color[].class});
< 
<              if (c.isInstance(paint)) {
<                  // User did pass a RadialGradientPaint object
<                  Method m = c.getMethod("getFractions", new Class[] {});
<                  Object fractions = m.invoke(paint, new Object[] {});
<                  m = c.getMethod("getColors", new Class[] {});
<                  Object clrs = m.invoke(paint, new Object[] {});
<                  Point2D center = getArcCenter(state, key);
<                  float radius = (new Float(state.getPieHRadius())).floatValue();
< 
<                  Paint radialPaint = (Paint) cc.newInstance(new Object[] {
<                          (Object) center, (Object) new Float(radius),
<                          fractions, clrs});
<                  // return the new RadialGradientPaint
<                  return radialPaint;
<              }
<         } catch (Exception e) {
---
>         // for a RadialGradientPaint we adjust the center and radius to match
>         // the current pie segment...
>         if (paint instanceof RadialGradientPaint) {
>             RadialGradientPaint rgp = (RadialGradientPaint) paint;
>             Point2D center = getArcCenter(state, key);
>             float radius = (float) Math.max(state.getPieHRadius(), 
>                     state.getPieWRadius());
>             float[] fractions = rgp.getFractions();
>             Color[] colors = rgp.getColors();
>             paint = new RadialGradientPaint(center, radius, fractions, colors);
3277d3267
<         // Return whatever it was
3288a3279
>     @Override
3480a3472
>     @Override
diff -r jfreechart-1.0.15/src/org/jfree/chart/plot/PolarPlot.java jfreechart-1.0.16/src/org/jfree/chart/plot/PolarPlot.java
57c57
<  * 12-Dec-2011 : Added support for radiusMinorGridilnesVisible (MH);
---
>  * 12-Dec-2011 : Added support for radiusMinorGridlinesVisible (MH);
58a59
>  * 05-Jul-2013 : Fire change event from setRadiusMinorGridlinesVisible (DG);
1044c1045,1046
<      * Set the flag that determines if radial minor grid-lines will be drawn.
---
>      * Set the flag that determines if radial minor grid-lines will be drawn,
>      * and sends a {@link PlotChangeEvent} to all registered listeners.
1051a1054
>         fireChangeEvent();
diff -r jfreechart-1.0.15/src/org/jfree/chart/plot/XYPlot.java jfreechart-1.0.16/src/org/jfree/chart/plot/XYPlot.java
229a230
>  * 12-Sep-2013 : Check for KEY_SUPPRESS_SHADOW_GENERATION rendering hint (DG);
262a264
> import org.jfree.chart.JFreeChart;
2416c2418
<      * to the range axis, however this is entirely up to the renderer.
---
>      * to the domain axis, however this is entirely up to the renderer.
2433c2435
<      * to the range axis, however this is entirely up to the renderer.
---
>      * to the domain axis, however this is entirely up to the renderer.
2474c2476
<      * renderer.
---
>      * renderer and sends a {@link PlotChangeEvent} to all registered listeners.
3038,3040c3040,3041
<     protected AxisSpace calculateDomainAxisSpace(Graphics2D g2,
<                                                  Rectangle2D plotArea,
<                                                  AxisSpace space) {
---
>     protected AxisSpace calculateDomainAxisSpace(Graphics2D g2, 
>             Rectangle2D plotArea, AxisSpace space) {
3085,3087c3086,3087
<     protected AxisSpace calculateRangeAxisSpace(Graphics2D g2,
<                                                 Rectangle2D plotArea,
<                                                 AxisSpace space) {
---
>     protected AxisSpace calculateRangeAxisSpace(Graphics2D g2, 
>             Rectangle2D plotArea, AxisSpace space) {
3148a3149
>     @Override
3268c3269,3271
<         if (this.shadowGenerator != null) {
---
>         boolean suppressShadow = Boolean.TRUE.equals(g2.getRenderingHint(
>                 JFreeChart.KEY_SUPPRESS_SHADOW_GENERATION));
>         if (this.shadowGenerator != null && !suppressShadow) {
3412c3415
<         if (this.shadowGenerator != null) {
---
>         if (this.shadowGenerator != null && !suppressShadow) {
3435a3439
>     @Override
4311a4316
>     @Override
4440a4446
>     @Override
4548a4555
>     @Override
4565a4573
>     @Override
4583a4592
>     @Override
4986a4996
>     @Override
5010a5021
>     @Override
5035a5047
>     @Override
5089a5102
>     @Override
5107a5121
>     @Override
5146a5161
>     @Override
5165a5181
>     @Override
5184a5201
>     @Override
5219a5237
>     @Override
5237a5256
>     @Override
5249a5269
>     @Override
5300a5321
>     @Override
5338a5360
>     @Override
5553a5576
>     @Override
diff -r jfreechart-1.0.15/src/org/jfree/chart/renderer/category/AbstractCategoryItemRenderer.java jfreechart-1.0.16/src/org/jfree/chart/renderer/category/AbstractCategoryItemRenderer.java
239a240
>     @Override
252a254
>     @Override
265a268
>     @Override
283a287
>     @Override
297a302
>     @Override
323a329
>     @Override
336a343
>     @Override
348a356
>     @Override
368a377
>     @Override
393a403
>     @Override
406a417
>     @Override
419a431
>     @Override
431a444
>     @Override
448a462
>     @Override
461a476
>     @Override
487a503
>     @Override
500a517
>     @Override
512a530
>     @Override
568a587
>     @Override
607a627
>     @Override
658a679
>     @Override
674a696
>     @Override
688a711
>     @Override
709a733
>     @Override
751a776
>     @Override
843a869
>     @Override
926a953
>     @Override
1154a1182
>     @Override
1206a1235
>     @Override
1272a1302
>     @Override
1282a1313
>     @Override
1355c1386
<             ItemLabelPosition position = null;
---
>             ItemLabelPosition position;
1381a1413
>     @Override
1528a1561
>     @Override
1750a1784
>     @Override
1767a1802
>     @Override
1785a1821
>     @Override
1801a1838
>     @Override
diff -r jfreechart-1.0.15/src/org/jfree/chart/renderer/xy/AbstractXYItemRenderer.java jfreechart-1.0.16/src/org/jfree/chart/renderer/xy/AbstractXYItemRenderer.java
259a260
>     @Override
268a270
>     @Override
277a280
>     @Override
299,304c302,304
<     public XYItemRendererState initialise(Graphics2D g2,
<                                           Rectangle2D dataArea,
<                                           XYPlot plot,
<                                           XYDataset data,
<                                           PlotRenderingInfo info) {
< 
---
>     @Override
>     public XYItemRendererState initialise(Graphics2D g2, Rectangle2D dataArea,
>             XYPlot plot, XYDataset data, PlotRenderingInfo info) {
307d306
< 
322a322
>     @Override
344a345
>     @Override
355a357
>     @Override
366a369
>     @Override
376a380
>     @Override
393a398
>     @Override
415a421
>     @Override
426a433
>     @Override
439a447
>     @Override
451a460
>     @Override
463a473
>     @Override
473a484
>     @Override
485a497
>     @Override
497a510
>     @Override
524a538
>     @Override
536a551
>     @Override
561a577
>     @Override
587a604
>     @Override
599a617
>     @Override
665a684
>     @Override
711a731
>     @Override
770a791
>     @Override
801a823
>     @Override
864a887
>     @Override
900a924
>     @Override
935,939c959,961
<     public void drawDomainGridLine(Graphics2D g2,
<                                    XYPlot plot,
<                                    ValueAxis axis,
<                                    Rectangle2D dataArea,
<                                    double value) {
---
>     @Override
>     public void drawDomainGridLine(Graphics2D g2, XYPlot plot, ValueAxis axis,
>             Rectangle2D dataArea, double value) {
1020,1026c1042,1044
<     public void drawRangeLine(Graphics2D g2,
<                               XYPlot plot,
<                               ValueAxis axis,
<                               Rectangle2D dataArea,
<                               double value,
<                               Paint paint,
<                               Stroke stroke) {
---
>     @Override
>     public void drawRangeLine(Graphics2D g2, XYPlot plot, ValueAxis axis,
>             Rectangle2D dataArea, double value, Paint paint, Stroke stroke) {
1060,1064c1078,1080
<     public void drawDomainMarker(Graphics2D g2,
<                                  XYPlot plot,
<                                  ValueAxis domainAxis,
<                                  Marker marker,
<                                  Rectangle2D dataArea) {
---
>     @Override
>     public void drawDomainMarker(Graphics2D g2, XYPlot plot, 
>             ValueAxis domainAxis, Marker marker, Rectangle2D dataArea) {
1231,1236c1247,1249
<             PlotOrientation orientation,
<             Rectangle2D dataArea,
<             Rectangle2D markerArea,
<             RectangleInsets markerOffset,
<             LengthAdjustmentType labelOffsetType,
<             RectangleAnchor anchor) {
---
>             PlotOrientation orientation, Rectangle2D dataArea,
>             Rectangle2D markerArea, RectangleInsets markerOffset,
>             LengthAdjustmentType labelOffsetType, RectangleAnchor anchor) {
1260,1264c1273,1275
<     public void drawRangeMarker(Graphics2D g2,
<                                 XYPlot plot,
<                                 ValueAxis rangeAxis,
<                                 Marker marker,
<                                 Rectangle2D dataArea) {
---
>     @Override
>     public void drawRangeMarker(Graphics2D g2, XYPlot plot, ValueAxis rangeAxis,
>             Marker marker, Rectangle2D dataArea) {
1431,1436c1442,1444
<                                       PlotOrientation orientation,
<                                       Rectangle2D dataArea,
<                                       Rectangle2D markerArea,
<                                       RectangleInsets markerOffset,
<                                       LengthAdjustmentType labelOffsetForRange,
<                                       RectangleAnchor anchor) {
---
>            PlotOrientation orientation, Rectangle2D dataArea,
>            Rectangle2D markerArea, RectangleInsets markerOffset,
>            LengthAdjustmentType labelOffsetForRange, RectangleAnchor anchor) {
1458a1467
>     @Override
1516a1526
>     @Override
1575a1586
>     @Override
1657c1668
<             ItemLabelPosition position = null;
---
>             ItemLabelPosition position;
1686,1691c1697,1700
<     public void drawAnnotations(Graphics2D g2,
<                                 Rectangle2D dataArea,
<                                 ValueAxis domainAxis,
<                                 ValueAxis rangeAxis,
<                                 Layer layer,
<                                 PlotRenderingInfo info) {
---
>     @Override
>     public void drawAnnotations(Graphics2D g2, Rectangle2D dataArea,
>             ValueAxis domainAxis, ValueAxis rangeAxis, Layer layer,
>             PlotRenderingInfo info) {
1853a1863
>     @Override
1887a1898
>     @Override
diff -r jfreechart-1.0.15/src/org/jfree/chart/renderer/xy/StackedXYAreaRenderer.java jfreechart-1.0.16/src/org/jfree/chart/renderer/xy/StackedXYAreaRenderer.java
258,261c258,259
<     public StackedXYAreaRenderer(int type,
<                                  XYToolTipGenerator labelGenerator,
<                                  XYURLGenerator urlGenerator) {
< 
---
>     public StackedXYAreaRenderer(int type, XYToolTipGenerator labelGenerator,
>             XYURLGenerator urlGenerator) {
330,334c328,329
<     public XYItemRendererState initialise(Graphics2D g2,
<                                           Rectangle2D dataArea,
<                                           XYPlot plot,
<                                           XYDataset data,
<                                           PlotRenderingInfo info) {
---
>     public XYItemRendererState initialise(Graphics2D g2, Rectangle2D dataArea,
>             XYPlot plot, XYDataset data, PlotRenderingInfo info) {
395,406c390,393
<     public void drawItem(Graphics2D g2,
<                          XYItemRendererState state,
<                          Rectangle2D dataArea,
<                          PlotRenderingInfo info,
<                          XYPlot plot,
<                          ValueAxis domainAxis,
<                          ValueAxis rangeAxis,
<                          XYDataset dataset,
<                          int series,
<                          int item,
<                          CrosshairState crosshairState,
<                          int pass) {
---
>     public void drawItem(Graphics2D g2, XYItemRendererState state,
>             Rectangle2D dataArea, PlotRenderingInfo info, XYPlot plot,
>             ValueAxis domainAxis, ValueAxis rangeAxis, XYDataset dataset,
>             int series, int item, CrosshairState crosshairState, int pass) {
433a421,424
>         Paint seriesFillPaint = seriesPaint;
>         if (getUseFillPaint()) {
>             seriesFillPaint = getItemFillPaint(series, item);
>         }
491a483,484
>                     g2.setPaint(seriesPaint);
>                     g2.setStroke(seriesStroke);
526c519
<                 g2.setPaint(seriesPaint);
---
>                 g2.setPaint(seriesFillPaint);
Only in jfreechart-1.0.16/src/org/jfree/chart/util: AttrStringUtils.java
diff -r jfreechart-1.0.15/src/org/jfree/chart/util/ParamChecks.java jfreechart-1.0.16/src/org/jfree/chart/util/ParamChecks.java
65c65
<             throw new IllegalArgumentException("Null '" + name + "' argument");
---
>             throw new IllegalArgumentException("Null '" + name + "' argument.");
diff -r jfreechart-1.0.15/src/org/jfree/data/DefaultKeyedValue.java jfreechart-1.0.16/src/org/jfree/data/DefaultKeyedValue.java
162,163c162
<         DefaultKeyedValue clone = (DefaultKeyedValue) super.clone();
<         return clone;
---
>         return (DefaultKeyedValue) super.clone();
diff -r jfreechart-1.0.15/src/org/jfree/data/DomainInfo.java jfreechart-1.0.16/src/org/jfree/data/DomainInfo.java
30c30
<  * (C) Copyright 2000-2009, by Object Refinery Limited.
---
>  * (C) Copyright 2000-2013, by Object Refinery Limited.
45a46
>  * 02-Aug-2013 : Updated Javadocs from David Tonhofer (bug 1117) (DG);
53c54,56
<  * determining the minimum and maximum values.
---
>  * determining the minimum and maximum values.  If not present, 
>  * {@link org.jfree.data.general.DatasetUtilities} will iterate over all the 
>  * values in the dataset to get the bounds.
63c66,67
<      * @return The minimum value.
---
>      * @return The minimum value or <code>Double.NaN</code> if there are no 
>      *     values.
73c77,78
<      * @return The maximum value.
---
>      * @return The maximum value or <code>Double.NaN</code> if there are no 
>      *     values.
diff -r jfreechart-1.0.15/src/org/jfree/data/DomainOrder.java jfreechart-1.0.16/src/org/jfree/data/DomainOrder.java
95d94
< 
diff -r jfreechart-1.0.15/src/org/jfree/data/general/DatasetUtilities.java jfreechart-1.0.16/src/org/jfree/data/general/DatasetUtilities.java
136a137
> import org.jfree.data.DomainOrder;
2254a2256,2400
>         }
>     }
> 
>     /**
>      * Returns the interpolated value of y that corresponds to the specified
>      * x-value in the given series.  If the x-value falls outside the range of
>      * x-values for the dataset, this method returns <code>Double.NaN</code>.
>      * 
>      * @param dataset  the dataset (<code>null</code> not permitted).
>      * @param series  the series index.
>      * @param x  the x-value.
>      * 
>      * @return The y value.
>      * 
>      * @since 1.0.16
>      */
>     public static double findYValue(XYDataset dataset, int series, double x) {
>         // delegate null check on dataset
>         int[] indices = findItemIndicesForX(dataset, series, x);
>         if (indices[0] == -1) {
>             return Double.NaN;
>         }
>         if (indices[0] == indices[1]) {
>             return dataset.getYValue(series, indices[0]);
>         }
>         double x0 = dataset.getXValue(series, indices[0]);
>         double x1 = dataset.getXValue(series, indices[1]);
>         double y0 = dataset.getYValue(series, indices[0]);
>         double y1 = dataset.getYValue(series, indices[1]);
>         return y0 + (y1 - y0) * (x - x0) / (x1 - x0);
>     }
>     
>     /**
>      * Finds the indices of the the items in the dataset that span the 
>      * specified x-value.  There are three cases for the return value:
>      * <ul>
>      * <li>there is an exact match for the x-value at index i 
>      * (returns <code>int[] {i, i}</code>);</li>
>      * <li>the x-value falls between two (adjacent) items at index i and i+1 
>      * (returns <code>int[] {i, i+1}</code>);</li>
>      * <li>the x-value falls outside the domain bounds, in which case the 
>      *    method returns <code>int[] {-1, -1}</code>.</li>
>      * </ul>
>      * @param dataset  the dataset (<code>null</code> not permitted).
>      * @param series  the series index.
>      * @param x  the x-value.
>      *
>      * @return The indices of the two items that span the x-value.
>      *
>      * @since 1.0.16
>      * 
>      * @see #findYValue(org.jfree.data.xy.XYDataset, int, double) 
>      */
>     public static int[] findItemIndicesForX(XYDataset dataset, int series,
>             double x) {
>         ParamChecks.nullNotPermitted(dataset, "dataset");
>         int itemCount = dataset.getItemCount(series);
>         if (itemCount == 0) {
>             return new int[] {-1, -1};
>         }
>         if (itemCount == 1) {
>             if (x == dataset.getXValue(series, 0)) {
>                 return new int[] {0, 0};
>             } else {
>                 return new int[] {-1, -1};
>             }
>         }
>         if (dataset.getDomainOrder() == DomainOrder.ASCENDING) {
>             int low = 0;
>             int high = itemCount - 1;
>             double lowValue = dataset.getXValue(series, low);
>             if (lowValue > x) {
>                 return new int[] {-1, -1};
>             }
>             if (lowValue == x) {
>                 return new int[] {low, low};
>             }
>             double highValue = dataset.getXValue(series, high);
>             if (highValue < x) {
>                 return new int[] {-1, -1};
>             }
>             if (highValue == x) {
>                 return new int[] {high, high};
>             }
>             int mid = (low + high) / 2;
>             while (high - low > 1) {
>                 double midV = dataset.getXValue(series, mid);
>                 if (x == midV) {
>                     return new int[] {mid, mid};
>                 }
>                 if (midV < x) {
>                     low = mid;
>                 }
>                 else {
>                     high = mid;
>                 }
>                 mid = (low + high) / 2;
>             }
>             return new int[] {low, high};
>         }
>         else if (dataset.getDomainOrder() == DomainOrder.DESCENDING) {
>             int high = 0;
>             int low = itemCount - 1;
>             double lowValue = dataset.getXValue(series, low);
>             if (lowValue > x) {
>                 return new int[] {-1, -1};
>             }
>             double highValue = dataset.getXValue(series, high);
>             if (highValue < x) {
>                 return new int[] {-1, -1};
>             }
>             int mid = (low + high) / 2;
>             while (high - low > 1) {
>                 double midV = dataset.getXValue(series, mid);
>                 if (x == midV) {
>                     return new int[] {mid, mid};
>                 }
>                 if (midV < x) {
>                     low = mid;
>                 }
>                 else {
>                     high = mid;
>                 }
>                 mid = (low + high) / 2;
>             }
>             return new int[] {low, high};
>         }
>         else {
>             // we don't know anything about the ordering of the x-values,
>             // so we iterate until we find the first crossing of x (if any)
>             // we know there are at least 2 items in the series at this point
>             double prev = dataset.getXValue(series, 0);
>             if (x == prev) {
>                 return new int[] {0, 0}; // exact match on first item
>             }
>             for (int i = 1; i < itemCount; i++) {
>                 double next = dataset.getXValue(series, i);
>                 if (x == next) {
>                     return new int[] {i, i}; // exact match
>                 }
>                 if ((x > prev && x < next) || (x < prev && x > next)) {
>                     return new int[] {i - 1, i}; // spanning match
>                 }
>             }
>             return new int[] {-1, -1}; // no crossing of x
diff -r jfreechart-1.0.15/src/org/jfree/data/time/Day.java jfreechart-1.0.16/src/org/jfree/data/time/Day.java
91c91
<     public static final DateFormat DATE_FORMAT
---
>     protected static final DateFormat DATE_FORMAT
95c95
<     public static final DateFormat
---
>     protected static final DateFormat
diff -r jfreechart-1.0.15/src/org/jfree/data/time/Month.java jfreechart-1.0.16/src/org/jfree/data/time/Month.java
484d483
<         	
489d487
<         	
492,494d489
<             if(month == -1) {
< //            	System.out.println(" year is not first, s1:  " + s1);
<             }
diff -r jfreechart-1.0.15/src/org/jfree/data/time/TimeSeriesCollection.java jfreechart-1.0.16/src/org/jfree/data/time/TimeSeriesCollection.java
671,672c671
<             Range r = null;
<             r = new Range(series.getMinY(), series.getMaxY());
---
>             Range r = new Range(series.getMinY(), series.getMaxY());
diff -r jfreechart-1.0.15/src/org/jfree/data/xy/XYSeries.java jfreechart-1.0.16/src/org/jfree/data/xy/XYSeries.java
140c140
<      * be allowed (these defaults can be modified with another constructor.
---
>      * be allowed (these defaults can be modified with another constructor).
826c826
<                 this.maxY = minIgnoreNaN(this.maxY, yy);
---
>                 this.maxY = maxIgnoreNaN(this.maxY, yy);
Only in jfreechart-1.0.16/src: overview.html
