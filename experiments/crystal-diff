diff -r crystalvc/src/crystal/client/CalculateProjectTask.java crystal/src/crystal/client/CalculateProjectTask.java
77c77
< 		_log.trace("Stating computing local state computed for " + _prefs.getEnvironment().getShortName());
---
> 		_log.trace("Stating computing local state computed for " + _prefs.getName());
79c79
< 		_log.trace("Local state computed for " + _prefs.getEnvironment().getShortName() + ": " + localStateResult);
---
> 		_log.trace("Local state computed for " + _prefs.getName() + ": " + localStateResult);
109c109
< 		_log.trace("Stating computing relationships for the " + _prefs.getEnvironment().getShortName() + "project");
---
> 		_log.trace("Stating computing relationships for the " + _prefs.getName() + "project");
111c111
< 			_log.trace("Stating computing relationships for the " + _prefs.getEnvironment().getShortName() + "project " + 
---
> 			_log.trace("Stating computing relationships for the " + _prefs.getName() + "project " + 
114c114
< 			_log.trace("Relationship computed for the " + _prefs.getEnvironment().getShortName() + "project " + 
---
> 			_log.trace("Relationship computed for the " + _prefs.getName() + "project " + 
118c118
< 		_log.trace("Finished computing relationships for the " + _prefs.getEnvironment().getShortName() + "project");
---
> 		_log.trace("Finished computing relationships for the " + _prefs.getName() + "project");
121c121
< 		_log.trace("Stating computing the guidance for the " + _prefs.getEnvironment().getShortName() + "project");
---
> 		_log.trace("Stating computing the guidance for the " + _prefs.getName() + "project");
154c154
< 		            _log.trace("Relationship and guidance computed for the " + _prefs.getEnvironment().getShortName() + "project " + 
---
> 		            _log.trace("Relationship and guidance computed for the " + _prefs.getName() + "project " + 
158c158
< 		        _log.trace("Finished computing the guidance for the " + _prefs.getEnvironment().getShortName() + "project");
---
> 		        _log.trace("Finished computing the guidance for the " + _prefs.getName() + "project");
160c160
< 		        _log.trace("My repo history couldn't be parsed, so I did not cimpute guidance for the " + _prefs.getEnvironment().getShortName() + "project");
---
> 		        _log.trace("My repo history couldn't be parsed, so I did not cimpute guidance for the " + _prefs.getName() + "project");
diff -r crystalvc/src/crystal/client/ClientPreferences.java crystal/src/crystal/client/ClientPreferences.java
216,217c216,217
<             if (pp.getEnvironment().getShortName().equals(pref.getEnvironment().getShortName())) {
<                 throw new DuplicateProjectNameException("Duplicate project name: " + pp.getEnvironment().getShortName());
---
>             if (pp.getName().equals(pref.getName())) {
>                 throw new DuplicateProjectNameException("Duplicate project name: " + pp.getName());
262c262
<             if (pp.getEnvironment().getShortName().equals(shortName)) {
---
>             if (pp.getName().equals(shortName)) {
650c650
<             projectElem.setAttribute(IPrefXML.LABEL[0], pp.getEnvironment().getShortName());
---
>             projectElem.setAttribute(IPrefXML.LABEL[0], pp.getName());
diff -r crystalvc/src/crystal/client/ConflictClient.java crystal/src/crystal/client/ConflictClient.java
255c255
<             JLabel projectName = new JLabel(projPref.getEnvironment().getShortName() + " ");
---
>             JLabel projectName = new JLabel(projPref.getName() + " ");
424c424
< 		JMenuItem clearProjectCacheMenu = new JMenuItem("Clear " + projPref.getEnvironment().getShortName() + " project cache");
---
> 		JMenuItem clearProjectCacheMenu = new JMenuItem("Clear " + projPref.getName() + " project cache");
428c428
< 				int option = JOptionPane.showConfirmDialog(null, "Do you want to empty the " + projPref.getEnvironment().getShortName() + " cache?", 
---
> 				int option = JOptionPane.showConfirmDialog(null, "Do you want to empty the " + projPref.getName() + " cache?", 
438c438
< 					target.add(_preferences.getTempDirectory() + projPref.getEnvironment().getShortName() + "_" + projPref.getEnvironment().getShortName());
---
> 					target.add(_preferences.getTempDirectory() + projPref.getName() + "_" + projPref.getName());
441c441
< 						target.add(_preferences.getTempDirectory() + projPref.getEnvironment().getShortName() + "_" + ds.getShortName());
---
> 						target.add(_preferences.getTempDirectory() + projPref.getName() + "_" + ds.getShortName());
449c449
< 					_log.info("Cleared the " + projPref.getEnvironment().getShortName() + " project's cache.");
---
> 					_log.info("Cleared the " + projPref.getName() + " project's cache.");
diff -r crystalvc/src/crystal/client/ConflictDaemon.java crystal/src/crystal/client/ConflictDaemon.java
135a136
> 			// TODO getRelationship never return null
203a205
> 			// TODO getLocalState never return null
295c297
< 	public void prePerformCalculations(ClientPreferences prefs) {
---
> 	/*public void prePerformCalculations(ClientPreferences prefs) {
313c315
< 	}
---
> 	}*/
diff -r crystalvc/src/crystal/client/ConflictSystemTray.java crystal/src/crystal/client/ConflictSystemTray.java
33,34c33,34
<  * The system tray icon UI. (This lives in the title bar in OS X or somewhere else in Linux). This UI contains a few menu options and allows opening
<  * up the larger window UI. If the system tray is not supported, the UI switches to a window-only view.
---
>  * The system tray icon UI. (This lives in the title bar in OS X or somewhere else in Linux). This UI contains a few menu options and allows opening up the larger window UI. If the
>  * system tray is not supported, the UI switches to a window-only view.
43,44c43,44
<     // The singleton instance.
<     private static ConflictSystemTray _instance;
---
> 	// The singleton instance.
> 	private static ConflictSystemTray _instance;
46,47c46,47
<     // The boolean that tells us if the OS supports the system tray.
<     public static boolean TRAY_SUPPORTED = SystemTray.isSupported();
---
> 	// The boolean that tells us if the OS supports the system tray.
> 	public static boolean TRAY_SUPPORTED = SystemTray.isSupported();
49,50c49,50
<     // The current Crystal version number.
<     public static String VERSION_ID = "1.0.20111015";
---
> 	// The current Crystal version number.
> 	public static String VERSION_ID = "2.0.20111120";
52,596c52,579
<     // A pointer to the Crystal window UI.
<     private ConflictClient _client;
< 
<     // The logger.
<     private Logger _log = Logger.getLogger(this.getClass());
< 
<     // The current configuration.
<     private ClientPreferences _prefs;
< 
<     // A timer that we use to refresh the results.
<     private Timer _timer;
< 
<     // A placekeeper to remember when we start each calculation.
<     long startCalculations = 0L;
< 
<     // A handle on the actual system tray.
<     final private SystemTray _tray;
< 
<     // The Crystal tray icon.
<     final private TrayIcon _trayIcon;
< 
<     // A menu element that dictates whether Crystal ConflictDeamon is running (refreshing).
<     private MenuItem _daemonEnabledItem;
< 
<     // A menu element that allows the user to start a new refresh right now.
<     private MenuItem _refreshItem;
< 
<     // The other menu elements are not referenced from listeners, so they are declared only locally.
< 
<     /**
<      * Constructs a brand new Crystal system tray icon, if the OS allows it. If the OS does not allow it, creates an empty tray icon object holding
<      * some nulls.
<      */
<     private ConflictSystemTray() {
<         _log.info("ConflictSystemTray - started at: " + TimeUtility.getCurrentLSMRDateString());
<         if (TRAY_SUPPORTED) {
<             _tray = SystemTray.getSystemTray();
<             // _trayIcon = new TrayIcon((new ImageIcon(Constants.class.getResource("/crystal/client/images/bulb.gif"))).getImage());
<             _trayIcon = new TrayIcon((new ImageIcon(Constants.class.getResource("/crystal/client/images/crystal-ball_blue_32.png"))).getImage());
<         } else {
<             _tray = null;
<             _trayIcon = null;
<         }
<     }
< 
<     /**
<      * A listener on the about menu item. When the user clicks on "about", a dialog pops up with some info on Crystal.
<      */
<     public void aboutAction() {
<         JOptionPane.showMessageDialog(
<                 null,
<                 "Crystal version: "
<                         + VERSION_ID
<                         + "\nBuilt by Yuriy Brun, Reid Holmes, and Haochen Wei." 
<                         + "\nContact crystalvc@googlegroups.com." 
<                         + "\nhttp://crystalvc.googlecode.com",
<                         "Crystal: Proactive Conflict Detector for Distributed Version Control", JOptionPane.PLAIN_MESSAGE, new ImageIcon(
<                                 Constants.class.getResource("/crystal/client/images/crystal-ball_blue_128.png")));
<     }
< 
<     /**
<      * Loads the Crystal preferences and creates the appropriate views
<      */
<     public void loadPreferences() {
<         try {
<             _prefs = ClientPreferences.loadPreferencesFromDefaultXML();
< 
<             if (_prefs != null) {
<                 _log.info("Preferences loaded successfully.");
<             } else {
<                 String msg = "Error loading preferences.";
< 
<                 System.err.println(msg);
<                 _log.error(msg);
<             }
<         } catch (IOException e) {
<             String msg = "Error reading the configuration file ( " + ClientPreferences.CONFIG_PATH + " )";
<             System.err.println(msg);
<             _log.error(msg);
< 
<             System.err.println(e.getMessage());
<             _log.error(e.getMessage());
< 
<             String dialogMessage = "The preferences file ( "
<                     + ClientPreferences.CONFIG_PATH
<                     + " ) is invalid and could not be loaded:\n > > > "
<                     + e.getMessage()
<                     + "\n"
<                     + "Do you want to edit it using the GUI?  This may overwrite your previous configuration file.  Your alternative is to edit the .xml file directly.";
<             int answer = JOptionPane.showConfirmDialog(null, dialogMessage, "Invalid configuration file", JOptionPane.YES_NO_OPTION,
<                     JOptionPane.WARNING_MESSAGE);
< 
<             if (answer == JOptionPane.YES_OPTION) {
<                 _prefs = ClientPreferences.DEFAULT_CLIENT_PREFERENCES;
<                 PreferencesGUIEditorFrame editorFrame = PreferencesGUIEditorFrame.getPreferencesGUIEditorFrame(_prefs);
<                 JOptionPane.showMessageDialog(editorFrame, "Please remember to restart the client after closing the configuraton editor.");
<                 // and disable client
<                 _daemonEnabledItem.setLabel("Start Crystal updates");
<                 if (_timer != null) {
<                     _timer.stop();
<                     _timer = null;
<                 }
< 
<                 // for (CalculateTask ct : tasks) {
<                 // _log.info("disabling ct of state: " + ct.getState());
<                 // ct.cancel(true);
<                 // }
< 
<             } else { // answer == JOptionPane.NO_OPTION
<                 System.out.println("User decided to edit the configuration file by hand");
<                 _log.trace("User decided to edit the configuration file by hand");
<                 quit(0);
<             }
<         }
< 
<         if (_prefs.hasChanged()) {
<             try {
<                 ClientPreferences.savePreferencesToDefaultXML(_prefs);
<             } catch (FileNotFoundException fnfe) {
<                 if (fnfe.getMessage().indexOf("Access is denied") >= 0)
<                     _log.info("XML file cannot be written to: " + fnfe);
<                 else
<                     _log.error(fnfe);
< 
<             }
<             _prefs.setChanged(false);
<         }
< 
<         // clear and reload the main window
<         showClient();
<         _client.reloadWindowBody(_prefs);
<         
<         if (!ConflictDaemon.getInstance().isEnabled()) 
<             _client.setDaemonEnabled(true);
< 
<         // refresh the window
<         performCalculations();
<     }
< 
<     /**
<      * Creates the Crystal system tray icon and installs in the tray.
<      */
<     private void createAndShowGUI() {
<         // Create components for a popup menu components to be used if System Tray is supported.
<         MenuItem aboutItem = new MenuItem("About");
<         MenuItem preferencesItem = new MenuItem("Edit Configuration");
<         _daemonEnabledItem = new MenuItem("Stop Crystal updates");
<         _refreshItem = new MenuItem("Refresh");
<         final MenuItem showClientItem = new MenuItem("Show Client");
<         MenuItem exitItem = new MenuItem("Exit");
< 
<         loadPreferences();
< 
<         // Check that we have a recent-enough version of hg
<         try {
<             if (!(RunIt.validHG(Constants.MIN_HG_VERSION, _prefs.getHgPath(), _prefs.getTempDirectory()))) {
<                 JOptionPane.showMessageDialog(null, 
<                         "Your computer is running an outdated version of hg.\nThe must be running at least version " + Constants.MIN_HG_VERSION, 
<                         "outdated hg", JOptionPane.ERROR_MESSAGE);
<                 quit(1);
<             }
<         } catch (IOException e) {
<             JOptionPane.showMessageDialog(null, "Encountered an exception while checking hg version", 
<                     "Error checking hg version", JOptionPane.ERROR_MESSAGE);
<             quit(1);
<         }
<         
<         //TODO check that we have a recent-enough version of git
<         
< 
< 
<         if (TRAY_SUPPORTED) {
<             final PopupMenu trayMenu = new PopupMenu();
<             _trayIcon.setImage((new ImageIcon(Constants.class.getResource("/crystal/client/images/16X16/must/clock.png"))).getImage());
< 
<             _trayIcon.setToolTip("Crystal");
< 
<             // Add components to the popup menu
<             trayMenu.add(aboutItem);
<             trayMenu.addSeparator();
<             trayMenu.add(preferencesItem);
<             trayMenu.add(_daemonEnabledItem);
<             trayMenu.addSeparator();
<             trayMenu.add(_refreshItem);
<             trayMenu.addSeparator();
<             trayMenu.add(showClientItem);
<             trayMenu.addSeparator();
<             trayMenu.add(exitItem);
< 
<             _trayIcon.setPopupMenu(trayMenu);
< 
<             try {
<                 _tray.add(_trayIcon);
<             } catch (AWTException e) {
<                 _log.error("TrayIcon could not be added.");
<                 return;
<             }
< 
<             _trayIcon.addActionListener(new ActionListener() {
<                 @Override
<                 public void actionPerformed(ActionEvent ae) {
<                     _log.trace("Tray icon ActionEvent: " + ae.getActionCommand());
<                     // doesn't work on OS X; it doesn't register double clicks on the tray
<                     showClient();
<                 }
<             });
< 
<             aboutItem.addActionListener(new ActionListener() {
<                 public void actionPerformed(ActionEvent e) {
<                     aboutAction();
<                 }
<             });
< 
<             _refreshItem.addActionListener(new ActionListener() {
<                 public void actionPerformed(ActionEvent e) {
<                     _log.info("Refresh manually selected.");
<                     performCalculations();
<                 }
<             });
< 
<             preferencesItem.addActionListener(new ActionListener() {
<                 public void actionPerformed(ActionEvent e) {
<                     preferencesAction();
<                 }
<             });
< 
<             showClientItem.addActionListener(new ActionListener() {
<                 public void actionPerformed(ActionEvent e) {
<                     showClient();
<                 }
<             });
< 
<             _daemonEnabledItem.addActionListener(new ActionListener() {
<                 public void actionPerformed(ActionEvent e) {
<                     daemonAbleAction();
<                 }
<             });
< 
<             exitItem.addActionListener(new ActionListener() {
<                 public void actionPerformed(ActionEvent e) {
<                     exitAction();
<                 }
<             });
< 
<         }
< 
<         ConflictDaemon.getInstance().addListener(this);
< 
<         performCalculations();
<     }
< 
<     /**
<      * Creates and starts a new timer (throws away the old one). The timer fires an update every refresh seconds, unless there is a pending task.
<      */
<     private void createTimer() {
< 
<         // note that the timer works in milliseconds and the argument is in seconds
< 
<         boolean pTask = false;
< 
<         // check if anything is PENDING (first local states then relationships
<         for (LocalStateResult localState : ConflictDaemon.getInstance().getLocalStates()) {
<             if (localState.getLocalState().equals(LocalStateResult.PENDING)) {
<                 pTask = true;
<             }
<         }
<         for (Relationship relationship : ConflictDaemon.getInstance().getRelationships()) {
<             if (!(relationship.isReady())) {
<                 pTask = true;
<             }
<         }
< 
<         final boolean pendingTask = pTask;
< 
<         if (_timer != null) {
<             _timer.stop();
<             _timer = null;
<         }
< 
<         _timer = new Timer((int) ClientPreferences.REFRESH * 1000, new ActionListener() {
< 
<             @Override
<             public void actionPerformed(ActionEvent e) {
<                 _log.info("Timer fired at: " + TimeUtility.getCurrentLSMRDateString());
<                 if (!pendingTask) {
<                     // if tasks are pending don't start the calculations again
<                     performCalculations();
<                 }
<             }
<         });
< 
<         _timer.setInitialDelay((int) ClientPreferences.REFRESH * 1000);
<         _timer.start();
< 
<         long nextFire = System.currentTimeMillis() + _timer.getDelay();
< 
<         _log.info("Timer created - will fire in: " + TimeUtility.msToHumanReadable(_timer.getInitialDelay()) + " (@ "
<                 + new SimpleDateFormat("HH:mm:ss").format(new Date(nextFire)) + ")");
<     }
< 
<     /**
<      * A listener for clicking the menu to enable the deamon.
<      */
<     public void daemonAbleAction() {
<         if (!ConflictDaemon.getInstance().isEnabled()) {
<             // daemon currently disabled
<             _log.info("Enabling ConflictDaemon");
<             _daemonEnabledItem.setLabel("Stop Crystal updates");
<             _refreshItem.setEnabled(true);
<             _client.setDaemonEnabled(true);
<             if (_timer != null) {
<                 // do it
<                 _timer.start();
<             } else {
<                 createTimer();
<             }
<         } else {
<             // daemon currently enabled
<             _log.info("Disabling ConflictDaemon");
<             _daemonEnabledItem.setLabel("Start Crystal updates");
<             _refreshItem.setEnabled(false);
<             _client.setDaemonEnabled(false);
<             if (_timer != null) {
<                 _timer.stop();
<                 _timer = null;
<             }
< 
<             // for (CalculateTask ct : tasks) {
<             // _log.info("disabling ct of state: " + ct.getState());
<             // ct.cancel(true);
<             // }
< 
<             update();
<         }
<     }
< 
<     /**
<      * A listener for clicking the menu to exit.
<      */
<     public void exitAction() {
<         if (TRAY_SUPPORTED)
<             _tray.remove(_trayIcon);
< 
<         String msg = "ConflictClient exited successfully.";
<         System.out.println(msg);
<         _log.trace("Exit action selected");
< 
<         quit(0);
<     }
< 
<     /**
<      * If the deamon is not running, does nothing. If the deamon is running, creates a new executor and performs the calculations on all repos of all
<      * projects of the current configuration.
<      */
<     public void performCalculations() {
< 
<         // if the daemon is disabled, don't perform calculations.
<         if (!ConflictDaemon.getInstance().isEnabled()) {
<             _log.error("Tried to perform calculations on a disabled daemon.");
<             return;
<         }
< 
<         // if the deamon is enabled.
<         // # lines marked with //# are removed to simplify the execution process
<         // # Executor ex = new SerialExecutor();
< 
<         _refreshItem.setLabel("Refreshing...");
<         _log.trace("refresh text: " + _refreshItem.getLabel());
<         _refreshItem.setEnabled(false);
<         _client.setCanUpdate(false);
< 
<         startCalculations = System.currentTimeMillis();
< 
<         // for (ProjectPreferences projPref : _prefs.getProjectPreference()) {
<         // final CalculateLocalStateTask clst = new CalculateLocalStateTask(projPref, this, _client);
<         // ex.execute(clst);
<         //
<         // for (final DataSource source : projPref.getDataSources()) {
<         // final CalculateRelationshipTask crt = new CalculateRelationshipTask(source, projPref, this, _client);
<         // ex.execute(crt);
<         // }
<         // }
< 
<         for (ProjectPreferences projPref : _prefs.getProjectPreference()) {
<             final CalculateProjectTask cpt = new CalculateProjectTask(projPref, this, _client);
<             // # ex.execute(cpt);
<             cpt.execute();
<         }
<     }
< 
<     /**
<      * Either creates a new one (if one did not exist) or displays the existing GUI configuration editor.
<      * @throws IOException 
<      */
<     public void preferencesAction(){
<         // stop the daemon if it's running
<         if (ConflictDaemon.getInstance().isEnabled())
<             daemonAbleAction();
<         PreferencesGUIEditorFrame.getPreferencesGUIEditorFrame(_prefs);
<     }
< 
<     /**
<      * Quit Crystal with a status.
<      * 
<      * @param status
<      *            : the exit status (0 means normal).
<      */
<     private void quit(int status) {
<         _log.info("ConflictSystemTray exited - code: " + status + " at: " + TimeUtility.getCurrentLSMRDateString());
< 
<         System.exit(status);
<     }
< 
<     /**
<      * Show the client and set up the timer.
<      */
<     private void showClient() {
<         _log.info("Show client requested");
<         if (_client != null) {
<             _client.show();
<         } else {
<             _client = new ConflictClient();
<             _client.createAndShowGUI(_prefs);
<         }
<     }
< 
<     /**
<      * Updates the images and tool tips of all the projects and all the repositories within the current configuration.
<      */
<     @Override
<     public void update() {
<         _log.trace("ConflictSystemTray::update()");
< 
<         // _log.trace("Task size in update: " + tasks.size());
<         
<         if (!ConflictDaemon.getInstance().isEnabled())
<             return;
<             
<         // check if anything is PENDING (first local states then relationships
<         boolean pendingTask = false;
<         for (LocalStateResult localState : ConflictDaemon.getInstance().getLocalStates()) {
<             if (localState.getLocalState().equals(LocalStateResult.PENDING)) {
<                 pendingTask = true;
<             }
<         }
<         for (Relationship relationship : ConflictDaemon.getInstance().getRelationships()) {
<             if (relationship.getName().equals(Relationship.PENDING)) {
<                 pendingTask = true;
<             }
<         }
< 
<         if (pendingTask) {
<             _log.trace("Update called with tasks still pending.");
< 
<             // keep the UI in updating mode
<             _refreshItem.setLabel("Refreshing...");
<             _refreshItem.setEnabled(false);
<             _client.setCanUpdate(false);
<         } else {
<             _log.trace("Update called with no tasks pending.");
< 
<             createTimer();
<             _refreshItem.setLabel("Refresh");
<             _refreshItem.setEnabled(true);
<             _client.setCanUpdate(true);
<         }
< 
<         if (TRAY_SUPPORTED)
<             updateTrayIcon();
< 
<         if (_client != null) {
<             _client.update();
<         }
<     }
< 
<     /**
<      * Updates the tray icon image to the harshest relationship in the current configuration.
<      */
<     private void updateTrayIcon() {
< 
<         if (!TRAY_SUPPORTED)
<             return;
< 
< //        _trayIcon.getImage().flush();
< 
<         Image icon = Relationship.getDominant(ConflictDaemon.getInstance().getRelationships());
< 
<         _trayIcon.setImage(icon);
<     }
< 
<     /**
<      * @return the single instance of ConflictSystemTray
<      */
<     public static ConflictSystemTray getInstance() {
<         if (_instance == null) {
<             _instance = new ConflictSystemTray();
<         }
<         return _instance;
<     }
< 
<     /**
<      * Main execution point that starts Crystal.
<      * 
<      * @param args
<      *            : --version : Prints the version number.
<      */
<     public static void main(String[] args) {
<         setLookAndFeel();
< 
<         if (args.length > 0) {
<             if (args[0].equals("--version")) {
<                 System.out.println("Crystal version: " + VERSION_ID);
<                 System.exit(0);
<             }
<         }
< 
<         ConflictSystemTray.startLogging();
<         // UIManager.put("swing.boldMetal", Boolean.FALSE);
< 
<         ConflictSystemTray cst = ConflictSystemTray.getInstance();
<         cst.createAndShowGUI();
<     }
< 
<     /**
<      * private: set the window to match the native look and feel of the
<      * operating system
<      */
<     private static void setLookAndFeel() {
<         try {
<             UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
<         } catch (UnsupportedLookAndFeelException e) {
<             // do nothing
<         } catch (ClassNotFoundException e) {
<             // do nothing
<         } catch (InstantiationException e) {
<             // do nothing
<         } catch (IllegalAccessException e) {
<             // do nothing
<         }
<     }
< 
< 
<     public static void startLogging() {
<         LSMRLogger.startLog4J(Constants.QUIET_CONSOLE, true, Constants.LOG_LEVEL, System.getProperty("user.home"), ".conflictClientLog");
<     }
---
> 	// A pointer to the Crystal window UI.
> 	private ConflictClient _client;
> 
> 	// The logger.
> 	private Logger _log = Logger.getLogger(this.getClass());
> 
> 	// The current configuration.
> 	private ClientPreferences _prefs;
> 
> 	// A timer that we use to refresh the results.
> 	private Timer _timer;
> 
> 	// A placekeeper to remember when we start each calculation.
> 	long startCalculations = 0L;
> 
> 	// A handle on the actual system tray.
> 	final private SystemTray _tray;
> 
> 	// The Crystal tray icon.
> 	final private TrayIcon _trayIcon;
> 
> 	// A menu element that dictates whether Crystal ConflictDeamon is running (refreshing).
> 	private MenuItem _daemonEnabledItem;
> 
> 	// A menu element that allows the user to start a new refresh right now.
> 	private MenuItem _refreshItem;
> 
> 	// The other menu elements are not referenced from listeners, so they are declared only locally.
> 
> 	/**
> 	 * Constructs a brand new Crystal system tray icon, if the OS allows it. If the OS does not allow it, creates an empty tray icon object holding some nulls.
> 	 */
> 	private ConflictSystemTray() {
> 		_log.info("ConflictSystemTray - started at: " + TimeUtility.getCurrentLSMRDateString());
> 		if (TRAY_SUPPORTED) {
> 			_tray = SystemTray.getSystemTray();
> 			// _trayIcon = new TrayIcon((new ImageIcon(Constants.class.getResource("/crystal/client/images/bulb.gif"))).getImage());
> 			_trayIcon = new TrayIcon((new ImageIcon(Constants.class.getResource("/crystal/client/images/crystal-ball_blue_32.png"))).getImage());
> 		} else {
> 			_tray = null;
> 			_trayIcon = null;
> 		}
> 	}
> 
> 	/**
> 	 * A listener on the about menu item. When the user clicks on "about", a dialog pops up with some info on Crystal.
> 	 */
> 	public void aboutAction() {
> 		JOptionPane.showMessageDialog(null, "Crystal version: " + VERSION_ID + "\nBuilt by Yuriy Brun, Reid Holmes, and Haochen Wei." + "\nContact crystalvc@googlegroups.com."
> 				+ "\nhttp://crystalvc.googlecode.com", "Crystal: Proactive Conflict Detector for Distributed Version Control", JOptionPane.PLAIN_MESSAGE, new ImageIcon(
> 				Constants.class.getResource("/crystal/client/images/crystal-ball_blue_128.png")));
> 	}
> 
> 	/**
> 	 * Loads the Crystal preferences and creates the appropriate views
> 	 */
> 	public void loadPreferences() {
> 		try {
> 			_prefs = ClientPreferences.loadPreferencesFromDefaultXML();
> 
> 			if (_prefs != null) {
> 				_log.info("Preferences loaded successfully.");
> 			} else {
> 				String msg = "Error loading preferences.";
> 
> 				System.err.println(msg);
> 				_log.error(msg);
> 			}
> 		} catch (IOException e) {
> 			String msg = "Error reading the configuration file ( " + ClientPreferences.CONFIG_PATH + " )";
> 			System.err.println(msg);
> 			_log.error(msg);
> 
> 			System.err.println(e.getMessage());
> 			_log.error(e.getMessage());
> 
> 			String dialogMessage = "The preferences file ( " + ClientPreferences.CONFIG_PATH + " ) is invalid and could not be loaded:\n > > > " + e.getMessage() + "\n"
> 					+ "Do you want to edit it using the GUI?  This may overwrite your previous configuration file.  Your alternative is to edit the .xml file directly.";
> 			int answer = JOptionPane.showConfirmDialog(null, dialogMessage, "Invalid configuration file", JOptionPane.YES_NO_OPTION, JOptionPane.WARNING_MESSAGE);
> 
> 			if (answer == JOptionPane.YES_OPTION) {
> 				_prefs = ClientPreferences.DEFAULT_CLIENT_PREFERENCES;
> 				PreferencesGUIEditorFrame editorFrame = PreferencesGUIEditorFrame.getPreferencesGUIEditorFrame(_prefs);
> 				JOptionPane.showMessageDialog(editorFrame, "Please remember to restart the client after closing the configuraton editor.");
> 				// and disable client
> 				_daemonEnabledItem.setLabel("Start Crystal updates");
> 				if (_timer != null) {
> 					_timer.stop();
> 					_timer = null;
> 				}
> 
> 				// for (CalculateTask ct : tasks) {
> 				// _log.info("disabling ct of state: " + ct.getState());
> 				// ct.cancel(true);
> 				// }
> 
> 			} else { // answer == JOptionPane.NO_OPTION
> 				System.out.println("User decided to edit the configuration file by hand");
> 				_log.trace("User decided to edit the configuration file by hand");
> 				quit(0);
> 			}
> 		}
> 
> 		if (_prefs.hasChanged()) {
> 			try {
> 				ClientPreferences.savePreferencesToDefaultXML(_prefs);
> 			} catch (FileNotFoundException fnfe) {
> 				if (fnfe.getMessage().indexOf("Access is denied") >= 0)
> 					_log.info("XML file cannot be written to: " + fnfe);
> 				else
> 					_log.error(fnfe);
> 
> 			}
> 			_prefs.setChanged(false);
> 		}
> 
> 		// clear and reload the main window
> 		showClient();
> 		_client.reloadWindowBody(_prefs);
> 
> 		if (!ConflictDaemon.getInstance().isEnabled())
> 			_client.setDaemonEnabled(true);
> 
> 		// refresh the window
> 		performCalculations();
> 	}
> 
> 	/**
> 	 * Creates the Crystal system tray icon and installs in the tray.
> 	 */
> 	private void createAndShowGUI() {
> 		// Create components for a popup menu components to be used if System Tray is supported.
> 		MenuItem aboutItem = new MenuItem("About");
> 		MenuItem preferencesItem = new MenuItem("Edit Configuration");
> 		_daemonEnabledItem = new MenuItem("Stop Crystal updates");
> 		_refreshItem = new MenuItem("Refresh");
> 		final MenuItem showClientItem = new MenuItem("Show Client");
> 		MenuItem exitItem = new MenuItem("Exit");
> 
> 		loadPreferences();
> 
> 		// Check that we have a recent-enough version of hg
> 		try {
> 			if (!(RunIt.validHG(Constants.MIN_HG_VERSION, _prefs.getHgPath(), _prefs.getTempDirectory()))) {
> 				JOptionPane.showMessageDialog(null, "Your computer is running an outdated version of hg.\nThe must be running at least version " + Constants.MIN_HG_VERSION,
> 						"outdated hg", JOptionPane.ERROR_MESSAGE);
> 				quit(1);
> 			}
> 		} catch (IOException e) {
> 			JOptionPane.showMessageDialog(null, "Encountered an exception while checking hg version", "Error checking hg version", JOptionPane.ERROR_MESSAGE);
> 			quit(1);
> 		}
> 
> 		// TODO check that we have a recent-enough version of git
> 
> 		if (TRAY_SUPPORTED) {
> 			final PopupMenu trayMenu = new PopupMenu();
> 			_trayIcon.setImage((new ImageIcon(Constants.class.getResource("/crystal/client/images/16X16/must/clock.png"))).getImage());
> 
> 			_trayIcon.setToolTip("Crystal");
> 
> 			// Add components to the popup menu
> 			trayMenu.add(aboutItem);
> 			trayMenu.addSeparator();
> 			trayMenu.add(preferencesItem);
> 			trayMenu.add(_daemonEnabledItem);
> 			trayMenu.addSeparator();
> 			trayMenu.add(_refreshItem);
> 			trayMenu.addSeparator();
> 			trayMenu.add(showClientItem);
> 			trayMenu.addSeparator();
> 			trayMenu.add(exitItem);
> 
> 			_trayIcon.setPopupMenu(trayMenu);
> 
> 			try {
> 				_tray.add(_trayIcon);
> 			} catch (AWTException e) {
> 				_log.error("TrayIcon could not be added.");
> 				return;
> 			}
> 
> 			_trayIcon.addActionListener(new ActionListener() {
> 				@Override
> 				public void actionPerformed(ActionEvent ae) {
> 					_log.trace("Tray icon ActionEvent: " + ae.getActionCommand());
> 					// doesn't work on OS X; it doesn't register double clicks on the tray
> 					showClient();
> 				}
> 			});
> 
> 			aboutItem.addActionListener(new ActionListener() {
> 				public void actionPerformed(ActionEvent e) {
> 					aboutAction();
> 				}
> 			});
> 
> 			_refreshItem.addActionListener(new ActionListener() {
> 				public void actionPerformed(ActionEvent e) {
> 					_log.info("Refresh manually selected.");
> 					performCalculations();
> 				}
> 			});
> 
> 			preferencesItem.addActionListener(new ActionListener() {
> 				public void actionPerformed(ActionEvent e) {
> 					preferencesAction();
> 				}
> 			});
> 
> 			showClientItem.addActionListener(new ActionListener() {
> 				public void actionPerformed(ActionEvent e) {
> 					showClient();
> 				}
> 			});
> 
> 			_daemonEnabledItem.addActionListener(new ActionListener() {
> 				public void actionPerformed(ActionEvent e) {
> 					daemonAbleAction();
> 				}
> 			});
> 
> 			exitItem.addActionListener(new ActionListener() {
> 				public void actionPerformed(ActionEvent e) {
> 					exitAction();
> 				}
> 			});
> 
> 		}
> 
> 		ConflictDaemon.getInstance().addListener(this);
> 
> 		performCalculations();
> 	}
> 
> 	/**
> 	 * Creates and starts a new timer (throws away the old one). The timer fires an update every refresh seconds, unless there is a pending task.
> 	 */
> 	private void createTimer() {
> 
> 		// note that the timer works in milliseconds and the argument is in seconds
> 
> 		boolean pTask = false;
> 
> 		// check if anything is PENDING (first local states then relationships
> 		for (LocalStateResult localState : ConflictDaemon.getInstance().getLocalStates()) {
> 			if (localState.getLocalState().equals(LocalStateResult.PENDING)) {
> 				pTask = true;
> 			}
> 		}
> 		for (Relationship relationship : ConflictDaemon.getInstance().getRelationships()) {
> 			if (!(relationship.isReady())) {
> 				pTask = true;
> 			}
> 		}
> 
> 		final boolean pendingTask = pTask;
> 
> 		if (_timer != null) {
> 			_timer.stop();
> 			_timer = null;
> 		}
> 
> 		_timer = new Timer((int) ClientPreferences.REFRESH * 1000, new ActionListener() {
> 
> 			@Override
> 			public void actionPerformed(ActionEvent e) {
> 				_log.info("Timer fired at: " + TimeUtility.getCurrentLSMRDateString());
> 				if (!pendingTask) {
> 					// if tasks are pending don't start the calculations again
> 					performCalculations();
> 				}
> 			}
> 		});
> 
> 		_timer.setInitialDelay((int) ClientPreferences.REFRESH * 1000);
> 		_timer.start();
> 
> 		long nextFire = System.currentTimeMillis() + _timer.getDelay();
> 
> 		_log.info("Timer created - will fire in: " + TimeUtility.msToHumanReadable(_timer.getInitialDelay()) + " (@ " + new SimpleDateFormat("HH:mm:ss").format(new Date(nextFire))
> 				+ ")");
> 	}
> 
> 	/**
> 	 * A listener for clicking the menu to enable the deamon.
> 	 */
> 	public void daemonAbleAction() {
> 		if (!ConflictDaemon.getInstance().isEnabled()) {
> 			// daemon currently disabled
> 			_log.info("Enabling ConflictDaemon");
> 			_daemonEnabledItem.setLabel("Stop Crystal updates");
> 			_refreshItem.setEnabled(true);
> 			_client.setDaemonEnabled(true);
> 			if (_timer != null) {
> 				// do it
> 				_timer.start();
> 			} else {
> 				createTimer();
> 			}
> 		} else {
> 			// daemon currently enabled
> 			_log.info("Disabling ConflictDaemon");
> 			_daemonEnabledItem.setLabel("Start Crystal updates");
> 			_refreshItem.setEnabled(false);
> 			_client.setDaemonEnabled(false);
> 			if (_timer != null) {
> 				_timer.stop();
> 				_timer = null;
> 			}
> 
> 			// for (CalculateTask ct : tasks) {
> 			// _log.info("disabling ct of state: " + ct.getState());
> 			// ct.cancel(true);
> 			// }
> 
> 			update();
> 		}
> 	}
> 
> 	/**
> 	 * A listener for clicking the menu to exit.
> 	 */
> 	public void exitAction() {
> 		if (TRAY_SUPPORTED)
> 			_tray.remove(_trayIcon);
> 
> 		String msg = "ConflictClient exited successfully.";
> 		System.out.println(msg);
> 		_log.trace("Exit action selected");
> 
> 		quit(0);
> 	}
> 
> 	/**
> 	 * If the deamon is not running, does nothing. If the deamon is running, creates a new executor and performs the calculations on all repos of all projects of the current
> 	 * configuration.
> 	 */
> 	public void performCalculations() {
> 
> 		// if the daemon is disabled, don't perform calculations.
> 		if (!ConflictDaemon.getInstance().isEnabled()) {
> 			_log.error("Tried to perform calculations on a disabled daemon.");
> 			return;
> 		}
> 
> 		// if the deamon is enabled.
> 		// # lines marked with //# are removed to simplify the execution process
> 		// # Executor ex = new SerialExecutor();
> 
> 		_refreshItem.setLabel("Refreshing...");
> 		_log.trace("refresh text: " + _refreshItem.getLabel());
> 		_refreshItem.setEnabled(false);
> 		_client.setCanUpdate(false);
> 
> 		startCalculations = System.currentTimeMillis();
> 
> 		// for (ProjectPreferences projPref : _prefs.getProjectPreference()) {
> 		// final CalculateLocalStateTask clst = new CalculateLocalStateTask(projPref, this, _client);
> 		// ex.execute(clst);
> 		//
> 		// for (final DataSource source : projPref.getDataSources()) {
> 		// final CalculateRelationshipTask crt = new CalculateRelationshipTask(source, projPref, this, _client);
> 		// ex.execute(crt);
> 		// }
> 		// }
> 
> 		for (ProjectPreferences projPref : _prefs.getProjectPreference()) {
> 			final CalculateProjectTask cpt = new CalculateProjectTask(projPref, this, _client);
> 			// # ex.execute(cpt);
> 			cpt.execute();
> 		}
> 	}
> 
> 	/**
> 	 * Either creates a new one (if one did not exist) or displays the existing GUI configuration editor.
> 	 * 
> 	 * @throws IOException
> 	 */
> 	public void preferencesAction() {
> 		// stop the daemon if it's running
> 		if (ConflictDaemon.getInstance().isEnabled())
> 			daemonAbleAction();
> 		PreferencesGUIEditorFrame.getPreferencesGUIEditorFrame(_prefs);
> 	}
> 
> 	/**
> 	 * Quit Crystal with a status.
> 	 * 
> 	 * @param status
> 	 *            : the exit status (0 means normal).
> 	 */
> 	private void quit(int status) {
> 		_log.info("ConflictSystemTray exited - code: " + status + " at: " + TimeUtility.getCurrentLSMRDateString());
> 
> 		System.exit(status);
> 	}
> 
> 	/**
> 	 * Show the client and set up the timer.
> 	 */
> 	private void showClient() {
> 		_log.info("Show client requested");
> 		if (_client != null) {
> 			_client.show();
> 		} else {
> 			_client = new ConflictClient();
> 			_client.createAndShowGUI(_prefs);
> 		}
> 	}
> 
> 	/**
> 	 * Updates the images and tool tips of all the projects and all the repositories within the current configuration.
> 	 */
> 	@Override
> 	public void update() {
> 		_log.trace("ConflictSystemTray::update()");
> 
> 		// _log.trace("Task size in update: " + tasks.size());
> 
> 		if (!ConflictDaemon.getInstance().isEnabled())
> 			return;
> 
> 		// check if anything is PENDING (first local states then relationships
> 		boolean pendingTask = false;
> 		for (LocalStateResult localState : ConflictDaemon.getInstance().getLocalStates()) {
> 			if (localState.getLocalState().equals(LocalStateResult.PENDING)) {
> 				pendingTask = true;
> 			}
> 		}
> 		for (Relationship relationship : ConflictDaemon.getInstance().getRelationships()) {
> 			if (relationship.getName().equals(Relationship.PENDING)) {
> 				pendingTask = true;
> 			}
> 		}
> 
> 		if (pendingTask) {
> 			_log.trace("Update called with tasks still pending.");
> 
> 			// keep the UI in updating mode
> 			_refreshItem.setLabel("Refreshing...");
> 			_refreshItem.setEnabled(false);
> 			_client.setCanUpdate(false);
> 		} else {
> 			_log.trace("Update called with no tasks pending.");
> 
> 			createTimer();
> 			_refreshItem.setLabel("Refresh");
> 			_refreshItem.setEnabled(true);
> 			_client.setCanUpdate(true);
> 		}
> 
> 		if (TRAY_SUPPORTED)
> 			updateTrayIcon();
> 
> 		if (_client != null) {
> 			_client.update();
> 		}
> 	}
> 
> 	/**
> 	 * Updates the tray icon image to the harshest relationship in the current configuration.
> 	 */
> 	private void updateTrayIcon() {
> 
> 		if (!TRAY_SUPPORTED)
> 			return;
> 
> 		// _trayIcon.getImage().flush();
> 
> 		Image icon = Relationship.getDominant(ConflictDaemon.getInstance().getRelationships());
> 
> 		_trayIcon.setImage(icon);
> 	}
> 
> 	/**
> 	 * @return the single instance of ConflictSystemTray
> 	 */
> 	public static ConflictSystemTray getInstance() {
> 		if (_instance == null) {
> 			_instance = new ConflictSystemTray();
> 		}
> 		return _instance;
> 	}
> 
> 	/**
> 	 * Main execution point that starts Crystal.
> 	 * 
> 	 * @param args
> 	 *            : --version : Prints the version number.
> 	 */
> 	public static void main(String[] args) {
> 		setLookAndFeel();
> 
> 		if (args.length > 0) {
> 			if (args[0].equals("--version")) {
> 				System.out.println("Crystal version: " + VERSION_ID);
> 				System.exit(0);
> 			}
> 		}
> 
> 		ConflictSystemTray.startLogging();
> 		// UIManager.put("swing.boldMetal", Boolean.FALSE);
> 
> 		ConflictSystemTray cst = ConflictSystemTray.getInstance();
> 		cst.createAndShowGUI();
> 	}
> 
> 	/**
> 	 * private: set the window to match the native look and feel of the operating system
> 	 */
> 	private static void setLookAndFeel() {
> 		try {
> 			UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
> 		} catch (UnsupportedLookAndFeelException e) {
> 			// do nothing
> 		} catch (ClassNotFoundException e) {
> 			// do nothing
> 		} catch (InstantiationException e) {
> 			// do nothing
> 		} catch (IllegalAccessException e) {
> 			// do nothing
> 		}
> 	}
> 
> 	public static void startLogging() {
> 		LSMRLogger.startLog4J(Constants.QUIET_CONSOLE, true, Constants.LOG_LEVEL, System.getProperty("user.home"), ".conflictClientLog");
> 	}
diff -r crystalvc/src/crystal/client/PreferencesGUIEditorFrame.java crystal/src/crystal/client/PreferencesGUIEditorFrame.java
94c94,95
< 		final Map<JTextField, Boolean> validText = new HashMap<JTextField, Boolean>();
---
> 		final Map<JTextField, Boolean> validEditorText = new HashMap<JTextField, Boolean>();
> 		final Map<ProjectPreferences, Map<JTextField, Boolean>> validTextSet = new HashMap<ProjectPreferences, Map<JTextField, Boolean>>();
96c97
< 		frame.setIconImage((new ImageIcon(Constants.class.getResource("/crystal/client/images/crystal-ball_blue_128.jpg"))).getImage());
---
> 		frame.setIconImage((new ImageIcon(Constants.class.getResource("/crystal/client/images/crystal-ball_blue_128.png"))).getImage());
172c173
< 		validText.put(tempPath, pathValid);
---
> 		validEditorText.put(tempPath, pathValid);
188c189
< 				validText.put(tempPath, pathValid);
---
> 				validEditorText.put(tempPath, pathValid);
234c235
< 		validText.put(refreshRate, true);
---
> 		validEditorText.put(refreshRate, true);
252c253
< 				validText.put(refreshRate, valid);
---
> 				validEditorText.put(refreshRate, valid);
277a279,280
> 				Map<JTextField, Boolean> validPanel = new HashMap<JTextField, Boolean>();
> 				validTextSet.put(copyPref, validPanel);
279c282
< 						changedComponents, prefs.getProjectPreferences(copyPref.getEnvironment().getShortName()), validText);
---
> 						changedComponents, prefs.getProjectPreferences(copyPref.getName()), validPanel);
285c288
< 				pnl.add(new DeleteProjectButton(copyPrefs, projectsTabs, frame, current, copyPref));
---
> 				pnl.add(new DeleteProjectButton(copyPrefs, projectsTabs, frame, current, copyPref, validTextSet));
302c305
< 					shortNameLookup.add(current.getEnvironment().getShortName());
---
> 					shortNameLookup.add(current.getName());
305c308
< 				while (shortNameLookup.contains("New Project " + count++))
---
> 				while (shortNameLookup.contains("New_Project_" + count++))
308c311
< 				final ProjectPreferences newGuy = new ProjectPreferences(new DataSource("New Project " + --count, "", DataSource.RepoKind.HG, false, null), copyPrefs);
---
> 				final ProjectPreferences newGuy = new ProjectPreferences(new DataSource("New_Project_" + --count, "", DataSource.RepoKind.HG, false, null), copyPrefs);
314c317
< 							"New Project " + count + "\nbut then the preferences told me that name was in use.  \n" + 
---
> 							"New_Project_" + count + "\nbut then the preferences told me that name was in use.  \n" + 
317,319c320,323
< 				
< 				final ProjectPanel newGuyPanel = new ProjectPanel(newGuy, copyPrefs, frame, projectsTabs, changedComponents, null, validText);
< 				projectsTabs.addTab("New Project " + count, newGuyPanel);
---
> 				Map<JTextField, Boolean> validPanel = new HashMap<JTextField, Boolean>();
> 				validTextSet.put(newGuy, validPanel);
> 				final ProjectPanel newGuyPanel = new ProjectPanel(newGuy, copyPrefs, frame, projectsTabs, changedComponents, null, validPanel);
> 				projectsTabs.addTab("New_Project_" + count, newGuyPanel);
321c325
< 				JLabel tabName = new JLabel(newGuy.getEnvironment().getShortName());
---
> 				JLabel tabName = new JLabel(newGuy.getName());
325c329
< 				pnl.add(new DeleteProjectButton(copyPrefs, projectsTabs, frame, newGuyPanel, newGuy));
---
> 				pnl.add(new DeleteProjectButton(copyPrefs, projectsTabs, frame, newGuyPanel, newGuy, validTextSet));
367,368c371,377
< 
< 					if(!validText.values().contains(false)){
---
> 					boolean validPanelText = true;
> 					for (Map<JTextField, Boolean> map : validTextSet.values()) {
> 						if (map.values().contains(false)) {
> 							validPanelText = false;
> 						}
> 					}
> 					if(!validEditorText.values().contains(false) && validPanelText){
405,411d413
< 						/*for (JTextField field : validText.keySet()) {
< 							if(validText.get(field) == false) {
< 								System.out.println(field.getText() + ": bad");
< 							} else {
< 								System.out.println(field.getText() + ": good");
< 							}
< 						}*/
413c415,421
< 						if(!validText.values().contains(false)){
---
> 						boolean validPanelText = true;
> 						for (Map<JTextField, Boolean> map : validTextSet.values()) {
> 							if (map.values().contains(false)) {
> 								validPanelText = false;
> 							}
> 						}
> 						if(!validEditorText.values().contains(false) && validPanelText){
466c474
< 				final ProjectPreferences newGuy) {
---
> 				final ProjectPreferences newGuy, final Map<ProjectPreferences, Map<JTextField, Boolean>> validTextSet) {
479c487
< 						if (tabName.equals(newGuy.getEnvironment().getShortName())) {
---
> 						if (tabName.equals(newGuy.getName())) {
486a495
> 						validTextSet.remove(newGuy);
diff -r crystalvc/src/crystal/client/ProjectPanel.java crystal/src/crystal/client/ProjectPanel.java
43d42
< 	
66c65
< 		_name = copyPref.getEnvironment().getShortName();
---
> 		_name = copyPref.getName();
76c75
< 		final JTextField shortName = new JTextField(copyPref.getEnvironment().getShortName());
---
> 		final JTextField shortName = new JTextField(copyPref.getName());
93c92,95
< 				copyPref.getEnvironment().setShortName(shortName.getText());
---
> 				boolean nameChanged = copyPref.setName(shortName.getText());
> 				if (nameChanged) {
> 					
> 				
97,99c99,102
< 				if (pref != null) {
< 					changedComponents.put(shortName, 
< 							!shortName.getText().equals(pref.getEnvironment().getShortName()));
---
> 					if (pref != null) {
> 						changedComponents.put(shortName, 
> 								!shortName.getText().equals(pref.getName()));
> 					}
101,103c104,106
< 				boolean valid = ValidInputChecker.checkProjectPreferencesNameDuplicate(copyPrefs, copyPref);
< 				validText.put(shortName, valid);
< 				setState(nameState, valid);
---
> 				//boolean valid = ValidInputChecker.checkProjectPreferencesNameDuplicate(copyPrefs, copyPref);
> 				validText.put(shortName, nameChanged);
> 				setState(nameState, nameChanged);
149c152
< //		type.addItem(DataSource.RepoKind.GIT);
---
> 		type.addItem(DataSource.RepoKind.GIT);
diff -r crystalvc/src/crystal/client/ProjectPreferences.java crystal/src/crystal/client/ProjectPreferences.java
58d57
< 	//TODO
115a115,135
> 	
> 	/**
> 	 * @return the name of the project
> 	 */
> 	public String getName() {
> 	    return _myEnvironment.getShortName();
> 	}
> 	
> 	/**
> 	 * @return true iff no other project in this project's client preferences has the name name.  
> 	 * @effect sets the name of this project to be name unless another project in this project's 
> 	 *          client preferences already has that name.  
> 	 */
> 	public boolean setName(String name) {
> 	    for (ProjectPreferences pp : _clientPreferences.getProjectPreference()) {
> 	        if ((pp.getName().equals(name)) && (pp != this))
> 	            return false;
> 	    }
> 	    _myEnvironment.setShortName(name);
> 	    return true;
> 	}
154c174
< 		return basePath + getEnvironment().getShortName() + "_" + source.getShortName();
---
> 		return basePath + getName() + "_" + source.getShortName();
diff -r crystalvc/src/crystal/Constants.java crystal/src/crystal/Constants.java
14,17c14,16
< 	/**   
< 	 * TIMER_CONSTANT is Crystal's refresh period, in milliseconds.
< 	 * Crystal will attempt to refresh the local state, actions, relationships, and guidance every
< 	 *   TIMER_CONSTANT milliseconds.  
---
> 	/**
> 	 * TIMER_CONSTANT is Crystal's refresh period, in milliseconds. Crystal will attempt to refresh the local state, actions, relationships, and guidance every TIMER_CONSTANT
> 	 * milliseconds.
19c18
< 	
---
> 
25c24
< 	//	public static long TIMER_CONSTANT = 1000; 
---
> 	// public static long TIMER_CONSTANT = 1000;
28c27
< 	
---
> 
30,32c29,30
<      * Minimum hg version
<      * may only contain 1 decimal point.
<      */
---
> 	 * Minimum hg version may only contain 1 decimal point.
> 	 */
51c49
< 	public static final Level LOG_LEVEL = Level.INFO;
---
> 	public static final Level LOG_LEVEL = Level.DEBUG;
diff -r crystalvc/src/crystal/model/DataSource.java crystal/src/crystal/model/DataSource.java
14,286c14,287
< 	public enum RepoKind {
< 		GIT, HG;
< 	}
< 	
< 	// whether or not this source is enabled
< 	private boolean _enabled;
< 	
< 	// whether or not this source should be hidden
< 	private boolean _hide;
< 
< 	// _shortName
< 	private String _shortName;
< 
< 	// the path to the remote repository
< 	private String _cloneString;
< 	
< 	// the shortName of the parent
< 	private String _parent;
< 
< 	// the kind of this repo
< 	private RepoKind _repoKind;
< 	
< 	// optional argument to pass to hg for --remotecmd in case the remote hg path is not just "hg"
< 	private String _remoteCmd = null;
< 
< 	// optional command for compiling a project
< 	private String _compileCommand = null;
< 	
< 	// optional command for compiling a project
< 	private String _testCommand = null;
< 	
< 	private RevisionHistory _history;
< 	private RevisionHistory _oldHistory;
< 
< 
< 	/**
< 	 * Creates a new DataSource
< 	 * @param shortName: the name of this repository
< 	 * @param cloneStrong: the path to the remote repository
< 	 * @param repoKind: the kind of this repository
< 	 * @param hide: false if this repository should not be shown in Crystal's view
< 	 * @param parent: the name of the parent repository
< 	 */
< 	public DataSource(String shortName, String cloneString, RepoKind repoKind, boolean hide, String parent) {
< 		//ValidInputChecker.checkValidStringInput(shortName);
< 		//ValidInputChecker.checkValidStringInput(cloneString);
< 		//ValidInputChecker.checkNullInput(repoKind);
< 		
< 		assert shortName != null;
< 		assert cloneString != null;
< 		// assert localString != null;
< 		assert repoKind != null;
< 
< 		_enabled = true;
< 		_shortName = shortName.replace(' ', '_').replace('\\', '_').replace('/', '_').replace(':', '_').replace(';', '_');
< 		_cloneString = cloneString;
< 		_repoKind = repoKind;
< 		_hide = hide;
< 		setParent(parent);
< 		_history = null;
< 		_oldHistory = null;
< 	}
< 	
< 	/**
< 	 * Return clone of this object.
< 	 */
< 	public DataSource clone() {
< 		try {  
< 			DataSource clone = (DataSource) super.clone();
< 			
< 			if (_history != null)
< 				clone._history = _history.clone();
< 			if (_oldHistory != null)
< 				clone._oldHistory = _oldHistory.clone();
< 			
< 			return clone;
< 		} catch (CloneNotSupportedException e) {
< 			return null;
< 		}
< 	}
< 	
< 	/**
< 	 * Compare this object with another object
< 	 * @param o other object to be compared with this object
< 	 * @return true if they have same short name; otherwise return false
< 	 */
< 	public boolean equals(Object o){
< 		if (o != null && getClass() == o.getClass()){
< 			DataSource other = (DataSource) o;
< 			return this._shortName == null && other._shortName == null 
< 			|| this._shortName.equals(other._shortName);
< 		} else {
< 			return false;
< 		}
< 	}
< 	
< 	/**
< 	 * Sets the history of this repository and moves the old history to _oldHistory
< 	 * @param history: the history 
< 	 */
< 	public void setHistory(RevisionHistory history) {
< 		//ValidInputChecker.checkNullInput(history);
< 		_oldHistory = _history;
< 		_history = history;
< 	}
< 		
< 	/**
< 	 * @return this repository's history
< 	 */
< 	public RevisionHistory getHistory() {
< 		return _history;
< 	}
< 	
< 	/**
< 	 * @return true iff the history has changed recently (if _history and _oldHistory are logically different)
< 	 */
< 	public boolean hasHistoryChanged() {
< 		if (_history == null)
< 			return true;
< 		return (!(_history.equals(_oldHistory)));
< 	}
< 	
< 	/**
< 	 * Sets the remoteHg command for this repository
< 	 * @param remoteHg : the remoteHg command
< 	 */
< 	public void setRemoteCmd(String remoteCmd) {
< 		_remoteCmd = remoteCmd;
< 	}
< 	
< 	/**
< 	 * @return the remoteHg command
< 	 */
< 	public String getRemoteCmd() {
< 		return _remoteCmd;
< 	}
< 	
< 	/**
< 	 * Sets the command to compile the code in this repository
< 	 * @param compileCommand: the compile command
< 	 */
< 	public void setCompileCommand(String compileCommand) {
< 		_compileCommand = compileCommand;
< 	}
< 	
< 	/**
< 	 * @return the compile command for this repository
< 	 */
< 	public String getCompileCommand() {
< 		return _compileCommand;
< 	}
< 	
< 	/**
< 	 * Sets the command to run the tests in this repository
< 	 * @param testCommand: the test command
< 	 */
< 	public void setTestCommand(String testCommand) {
< 		_testCommand = testCommand;
< 	}
< 	
< 	/**
< 	 * @return the test command for this repository
< 	 */
< 	public String getTestCommand() {
< 		return _testCommand;
< 	}
< 
< 	/**
< 	 * @return the name of this repository
< 	 */
< 	public String getShortName() {
< 		return _shortName;
< 	}
< 
< 	/**
< 	 * @return the path to the remote repository
< 	 */
< 	public String getCloneString() {
< 		return _cloneString;
< 	}
< 	
< 	/**
< 	 * Set whether this repository is enabled (or ignored by Crystal)
< 	 * @param enabled: true iff the repository is becoming enabled (regardless of what it was before)
< 	 */
< 	public void setEnabled(boolean enabled) {
< 		_enabled = enabled;
< 	}
< 
< 	/**
< 	 * @return true iff this repository is enabled
< 	 */
< 	public boolean isEnabled() {
< 		return _enabled;
< 	}
< 	
< 	/**
< 	 * @return true iff this repository is hidden
< 	 */
< 	public boolean isHidden() {
< 		return _hide;
< 	}
< 	
< 	/**
< 	 * Set whether this repository is hidden (= not shown by Crystal)
< 	 * @param hide: true iff the repository is becoming hidden (regardless of what it was before)
< 	 */
< 	public void hide(boolean hide) {
< 		_hide = hide;
< 	}
< 	
< 	/**
< 	 * @return this repository's parent's name
< 	 */
< 	public String getParent() {
< 		if (_parent == null)
< 			return "";
< 		else
< 			return _parent;
< 	}
< 	
< 	/**
< 	 * Sets the parent name of this repository
< 	 * @param parent: the shortName of the parent
< 	 */
< 	public void setParent(String parent) {
< 		if ((parent == null) || (parent.trim().equals("")))
< 			_parent = null;
< 		else
< 			_parent = parent;
< 	}
< 	
< 	/**
< 	 * @return the kind of this repository
< 	 */
< 	public RepoKind getKind() {
< 		return _repoKind;
< 	}
< 
< 	/**
< 	 * Sets the kind of this repository
< 	 * @param kind: the kind of this repository
< 	 */
< 	public void setKind(RepoKind kind) {
< 		//ValidInputChecker.checkNullInput(kind);
< 		_repoKind = kind;
< 	}
< 
< 	/**
< 	 * Sets this repository's name
< 	 * @param name: this repository's name
< 	 */
< 	public void setShortName(String name) {
< 		ValidInputChecker.checkValidStringInput(name);
< 		_shortName = name.replace(' ', '_').replace('\\', '_').replace('/', '_').replace(':', '_').replace(';', '_');
< 	}
< 
< 	/**
< 	 * Sets this repository's remote path
< 	 * @param name: this repository's remote path
< 	 */
< 	public void setCloneString(String name) {
< 		ValidInputChecker.checkValidStringInput(name);
< 		_cloneString = name;
< 	}
< 
< 	/**
< 	 * Converts this repository to a String representation
< 	 */
< 	@Override
< 	public String toString() {
< 		return getShortName() + "_" + getKind() + "_" + getCloneString();
< 	}
---
>     public enum RepoKind {
>         GIT, HG;
>     }
> 
>     // whether or not this source is enabled
>     private boolean _enabled;
> 
>     // whether or not this source should be hidden
>     private boolean _hide;
> 
>     // _shortName
>     private String _shortName;
> 
>     // the path to the remote repository
>     private String _cloneString;
> 
>     // the shortName of the parent
>     private String _parent;
> 
>     // the kind of this repo
>     private RepoKind _repoKind;
> 
>     // optional argument to pass to hg for --remotecmd in case the remote hg path is not just "hg"
>     private String _remoteCmd = null;
> 
>     // optional command for compiling a project
>     private String _compileCommand = null;
> 
>     // optional command for compiling a project
>     private String _testCommand = null;
> 
>     private RevisionHistory _history;
>     private RevisionHistory _oldHistory;
> 
> 
>     /**
>      * Creates a new DataSource
>      * @param shortName: the name of this repository
>      * @param cloneStrong: the path to the remote repository
>      * @param repoKind: the kind of this repository
>      * @param hide: false if this repository should not be shown in Crystal's view
>      * @param parent: the name of the parent repository
>      */
>     public DataSource(String shortName, String cloneString, RepoKind repoKind, boolean hide, String parent) {
>         //ValidInputChecker.checkValidStringInput(shortName);
>         //ValidInputChecker.checkValidStringInput(cloneString);
>         //ValidInputChecker.checkNullInput(repoKind);
> 
>         assert shortName != null;
>         assert cloneString != null;
>         // assert localString != null;
>         assert repoKind != null;
> 
>         _enabled = true;
>         _shortName = shortName.replace(' ', '_').replace('\\', '_').replace('/', '_').replace(':', '_').replace(';', '_');
>         _cloneString = cloneString;
>         _repoKind = repoKind;
>         _hide = hide;
>         setParent(parent);
>         _history = null;
>         _oldHistory = null;
>     }
> 
>     /**
>      * Return clone of this object.
>      */
>     public DataSource clone() {
>         try {  
>             DataSource clone = (DataSource) super.clone();
> 
>             if (_history != null)
>                 clone._history = _history.clone();
>             if (_oldHistory != null)
>                 clone._oldHistory = _oldHistory.clone();
> 
>             return clone;
>         } catch (CloneNotSupportedException e) {
>             return null;
>         }
>     }
> 
>     /**
>      * Compare this object with another object
>      * @param o other object to be compared with this object
>      * @return true if they have same short name; otherwise return false
>      */
>     public boolean equals(Object o){
>         if (o != null && getClass() == o.getClass()){
>             DataSource other = (DataSource) o;
>             return this._shortName == null && other._shortName == null 
>                     || this._shortName.equals(other._shortName);
>         } else {
>             return false;
>         }
>     }
> 
>     /**
>      * Sets the history of this repository and moves the old history to _oldHistory
>      * @param history: the history 
>      */
>     public void setHistory(RevisionHistory history) {
>         //ValidInputChecker.checkNullInput(history);
>         _oldHistory = _history;
>         _history = history;
>     }
> 
>     /**
>      * @return this repository's history
>      */
>     public RevisionHistory getHistory() {
>         return _history;
>     }
> 
>     /**
>      * @return true iff the history has changed recently (if _history and _oldHistory are logically different)
>      */
>     public boolean hasHistoryChanged() {
>         if (_history == null)
>             return true;
>         return (!(_history.equals(_oldHistory)));
>     }
> 
>     /**
>      * Sets the remoteHg command for this repository
>      * @param remoteHg : the remoteHg command
>      */
>     public void setRemoteCmd(String remoteCmd) {
>         _remoteCmd = remoteCmd;
>     }
> 
>     /**
>      * @return the remoteHg command
>      */
>     public String getRemoteCmd() {
>         return _remoteCmd;
>     }
> 
>     /**
>      * Sets the command to compile the code in this repository
>      * @param compileCommand: the compile command
>      */
>     public void setCompileCommand(String compileCommand) {
>         _compileCommand = compileCommand;
>     }
> 
>     /**
>      * @return the compile command for this repository
>      */
>     public String getCompileCommand() {
>         return _compileCommand;
>     }
> 
>     /**
>      * Sets the command to run the tests in this repository
>      * @param testCommand: the test command
>      */
>     public void setTestCommand(String testCommand) {
>         _testCommand = testCommand;
>     }
> 
>     /**
>      * @return the test command for this repository
>      */
>     public String getTestCommand() {
>         return _testCommand;
>     }
> 
>     /**
>      * @return the name of this repository
>      */
>     public String getShortName() {
>         return _shortName;
>     }
> 
>     /**
>      * Sets this repository's name
>      * @param name: this repository's name
>      */
>     public void setShortName(String name) {
>         ValidInputChecker.checkValidStringInput(name);
>         _shortName = name.replace(' ', '_').replace('\\', '_').replace('/', '_').replace(':', '_').replace(';', '_');
>     }
> 
> 
>     /**
>      * @return the path to the remote repository
>      */
>     public String getCloneString() {
>         return _cloneString;
>     }
> 
>     /**
>      * Set whether this repository is enabled (or ignored by Crystal)
>      * @param enabled: true iff the repository is becoming enabled (regardless of what it was before)
>      */
>     public void setEnabled(boolean enabled) {
>         _enabled = enabled;
>     }
> 
>     /**
>      * @return true iff this repository is enabled
>      */
>     public boolean isEnabled() {
>         return _enabled;
>     }
> 
>     /**
>      * @return true iff this repository is hidden
>      */
>     public boolean isHidden() {
>         return _hide;
>     }
> 
>     /**
>      * Set whether this repository is hidden (= not shown by Crystal)
>      * @param hide: true iff the repository is becoming hidden (regardless of what it was before)
>      */
>     public void hide(boolean hide) {
>         _hide = hide;
>     }
> 
>     /**
>      * @return this repository's parent's name
>      */
>     public String getParent() {
>         if (_parent == null)
>             return "";
>         else
>             return _parent;
>     }
> 
>     /**
>      * Sets the parent name of this repository
>      * @param parent: the shortName of the parent
>      */
>     public void setParent(String parent) {
>         if ((parent == null) || (parent.trim().equals("")))
>             _parent = null;
>         else
>             _parent = parent;
>     }
> 
>     /**
>      * @return the kind of this repository
>      */
>     public RepoKind getKind() {
>         return _repoKind;
>     }
> 
>     /**
>      * Sets the kind of this repository
>      * @param kind: the kind of this repository
>      */
>     public void setKind(RepoKind kind) {
>         //ValidInputChecker.checkNullInput(kind);
>         _repoKind = kind;
>     }
> 
>     /**
>      * Sets this repository's remote path
>      * @param name: this repository's remote path
>      */
>     public void setCloneString(String name) {
>         ValidInputChecker.checkValidStringInput(name);
>         _cloneString = name;
>     }
> 
>     /**
>      * Converts this repository to a String representation
>      */
>     @Override
>     public String toString() {
>         return getShortName() + "_" + getKind() + "_" + getCloneString();
>     }
diff -r crystalvc/src/crystal/model/Relationship.java crystal/src/crystal/model/Relationship.java
375c375,377
< 		if ((parent == null) || (localState == LocalStateResult.PENDING))
---
> 		if (localState == null)
> 			_action = null;
> 		else if ((parent == null) || (localState == LocalStateResult.PENDING))
379,380c381,382
< 		else if (localState.equals(LocalStateResult.HG_MUST_RESOLVE) 
< 				|| localState.equals(LocalStateResult.GIT_MUST_RESOLVE))
---
> 		else if (localState == (LocalStateResult.HG_MUST_RESOLVE) 
> 				|| localState == (LocalStateResult.GIT_MUST_RESOLVE))
382,383c384,385
< 		else if (localState.equals(LocalStateResult.HG_UNCHECKPOINTED)
< 				|| localState.equals(LocalStateResult.GIT_UNCHECKPOINTED))
---
> 		else if (localState == (LocalStateResult.HG_UNCHECKPOINTED)
> 				|| localState == (LocalStateResult.GIT_UNCHECKPOINTED))
501a504,507
> 		
> 		if (dominant == null) {
> 			return null;
> 		}
diff -r crystalvc/src/crystal/model/RevisionHistory.java crystal/src/crystal/model/RevisionHistory.java
198c198,201
< 		return answer.substring(0, answer.length() - 1);
---
> 		if (answer.isEmpty())
> 		       return answer;
> 		else
> 		    return answer.substring(0, answer.length() - 1);
diff -r crystalvc/src/crystal/server/AbstractLogParser.java crystal/src/crystal/server/AbstractLogParser.java
130a131
> 		String prevChangeset = null;
156a158
> 							nextParent = nextParent.substring(nextParent.indexOf(":")+1);
193a196,203
> 					// if it is empty parent
> 					if(parents.isEmpty()){
> 						// if this is not the top of the history
> 						if(prevChangeset != null) {
> 							// set parent as previous changeset
> 							parents.add(prevChangeset);
> 						}
> 					}
194a205,207
> 					// update change set to current change set
> 					prevChangeset = changeset.intern();
> 
diff -r crystalvc/src/crystal/server/AbstractStateChecker.java crystal/src/crystal/server/AbstractStateChecker.java
23d22
< import crystal.util.TimeUtility;
24a24
> import crystal.util.TimeUtility;
27c27,30
<     
---
> 
> 	/** using for comparing output */
> 	private static Logger _log = Logger.getLogger(AbstractStateChecker.class);
> 
29,32c32,39
< 	 * @param String pathToGit: the path to the executable
< 	 * @param String pathToRepo: the full path to the remote repo
< 	 * @param String tempWorkPath: path to a temp directory
< 	 * @param RepoKind kind: type of the repository
---
> 	 * @param String
> 	 *            pathToGit: the path to the executable
> 	 * @param String
> 	 *            pathToRepo: the full path to the remote repo
> 	 * @param String
> 	 *            tempWorkPath: path to a temp directory
> 	 * @param RepoKind
> 	 *            kind: type of the repository
49,52c56,63
< 	 * @param String pathToGit: the path to the git executable
< 	 * @param String pathToRemoteRepo: the full path to the remote repo
< 	 * @param String pathToLocalRepo: the path to the local repo which this method creates
< 	 * @param String tempWorkPath: path to a temp directory
---
> 	 * @param String
> 	 *            pathToGit: the path to the git executable
> 	 * @param String
> 	 *            pathToRemoteRepo: the full path to the remote repo
> 	 * @param String
> 	 *            pathToLocalRepo: the path to the local repo which this method creates
> 	 * @param String
> 	 *            tempWorkPath: path to a temp directory
56c67
< 	throws IOException, OperationException {
---
> 			throws IOException, OperationException {
61c72
< 
---
> 		// _log.info("create local repository");
69,70c80,81
< 		String command = pathExecutable + " clone"; 
< 	
---
> 		String command = pathExecutable + " clone";
> 
73c84
< 		if (remoteCmd != null) { 
---
> 		if (remoteCmd != null) {
76c87
< 			command += " --remotecmd " + remoteCmd; 
---
> 			command += " --remotecmd " + remoteCmd;
80,81c91,92
< 		command += " " + pathToRemoteRepo + " " + pathToLocalRepo; 
< 		
---
> 		command += " " + pathToRemoteRepo + " " + pathToLocalRepo;
> 
82a94,100
> 		if (pathExecutable.contains("git")) {
> 			_log.info("create local repository");
> 			_log.info("run command: " + command);
> 			_log.info("output: " + output.getOutput());
> 			if (output.getError().length() > 0) {
> 				_log.info("error: " + output.getError());
> 			}
84,90c102,106
< 		if (output.getOutput().indexOf("updating to branch") < 0) {
< 			String errorMsg = "Crystal tried to execute command:\n" +
< 			"\"" + pathExecutable + " clone " + pathToRemoteRepo + " " + pathToLocalRepo + "\"\n" +
< 			"from \"" + tempWorkPath + "\"\n" +
< 			"but got the unexpected output:\n" + 
< 			output.toString();
< 		//	JOptionPane.showMessageDialog(null, dialogMsg, "git clone failure", JOptionPane.ERROR_MESSAGE);
---
> 		}
> 		if (output.getOutput().indexOf("updating to branch") < 0 && output.getOutput().indexOf("done.") < 0) {
> 			String errorMsg = "Crystal tried to execute command:\n" + "\"" + pathExecutable + " clone " + pathToRemoteRepo + " " + pathToLocalRepo + "\"\n" + "from \""
> 					+ tempWorkPath + "\"\n" + "but got the unexpected output:\n" + output.toString();
> 			// JOptionPane.showMessageDialog(null, dialogMsg, "git clone failure", JOptionPane.ERROR_MESSAGE);
92c108
< 		//			throw new RuntimeException("Could not clone repository " + pathToRemoteRepo + " to " + pathToLocalRepo + "\n" + output);
---
> 			// throw new RuntimeException("Could not clone repository " + pathToRemoteRepo + " to " + pathToLocalRepo + "\n" + output);
97,100c113,119
< 	 * @param String pathToGit: the path to the git executable
< 	 * @param String pathToLocalRepo: the path to the local repo which this method creates
< 	 * @param String tempWorkPath: path to a temp directory
< 	 * @return 
---
> 	 * @param String
> 	 *            pathExecutable: the path to the executable
> 	 * @param String
> 	 *            pathToLocalRepo: the path to the local repo which this method creates
> 	 * @param String
> 	 *            tempWorkPath: path to a temp directory
> 	 * @return
103,104c122,123
< 	protected static synchronized  void updateLocalRepository(String pathExecutable, String pathToLocalRepo, String pathToRemoteRepo, String tempWorkPath, 
< 														   String remoteCmd) throws IOException, OperationException {
---
> 	protected static synchronized void updateLocalRepository(String pathExecutable, String pathToLocalRepo, String pathToRemoteRepo, String tempWorkPath, String remoteCmd)
> 			throws IOException, OperationException {
108a128,129
> 		// _log.info("update local repository");
> 
114c135
< 		if (remoteCmd != null) { 
---
> 		if (remoteCmd != null) {
117c138
< 			command += "--remotecmd " + remoteCmd; 
---
> 			command += "--remotecmd " + remoteCmd;
120c141
< //		String[] myArgs = { "pull", "-u" };
---
> 		// String[] myArgs = { "pull", "-u" };
122,123c143,151
< 		
< 		//TODO only for hg
---
> 		if (pathExecutable.contains("git")) {
> 			_log.info("update local repository");
> 			_log.info("run command: " + command);
> 			_log.info("output: \n" + output.getOutput());
> 			if (output.getError().length() > 0) {
> 				_log.info("error: " + output.getError());
> 			}
> 		}
> 		// TODO only for hg
126a155,163
> 
> 		// for git
> 		if (pathExecutable.contains("git") && (output.getOutput().indexOf("Fast-forward") < 0) && (output.getOutput().indexOf("Already up-to-date.") < 0)) {
> 			throw new OperationException(command, pathToLocalRepo, output.toString());
> 		}
> 
> 		/*
> 		 * if (pathExecutable.contains("git")) { _log.info("output: \n" + output.getOutput() + "\n error: \n" + output.getError()); }
> 		 */
128c165
< 	
---
> 
130,137c167,182
< 	 * Pulls into the local repo and checks for an error in the cache.  
< 	 * @param ds: the repo to pull into
< 	 * @param Git: path to git executable
< 	 * @param localRepo: path to the local copy of the repo
< 	 * @param tempWorkPath: the temp path
< 	 * @param remoteGit: the optional remoteGit command (null if none)
< 	 * @param repoName: the name of the repo
< 	 * @param projectName: the name of the project
---
> 	 * Pulls into the local repo and checks for an error in the cache.
> 	 * 
> 	 * @param ds
> 	 *            : the repo to pull into
> 	 * @param Git
> 	 *            : path to git executable
> 	 * @param localRepo
> 	 *            : path to the local copy of the repo
> 	 * @param tempWorkPath
> 	 *            : the temp path
> 	 * @param remoteGit
> 	 *            : the optional remoteGit command (null if none)
> 	 * @param repoName
> 	 *            : the name of the repo
> 	 * @param projectName
> 	 *            : the name of the project
141,142c186,188
< 	protected static void updateLocalRepositoryAndCheckCacheError(DataSource ds, String pathExecutable, String localRepo, String tempWorkPath, String remoteCmd, 
< 																String repoName, String projectName) throws OperationException, IOException {
---
> 	protected static synchronized void updateLocalRepositoryAndCheckCacheError(DataSource ds, String pathExecutable, String localRepo, String tempWorkPath, String remoteCmd,
> 			String repoName, String projectName) throws OperationException, IOException {
> 		// _log.info("update local repository and check cache error");
143a190,191
> 		_log.info("call update local repository and check cache error");
> 		_log.info("local repository: " + localRepo + ", exist?: " + (new File(localRepo).exists()));
145a194
> 				_log.info("trying to update local repository: " + localRepo);
146a196
> 				_log.info("successfully finished updating local repository: " + localRepo);
148,152c198,201
< 				String errorMsg = "Crystal is having trouble executing\n" + e.getCommand() + "\nin " +
< 				e.getPath() + "\n for your " + repoName + " repository of project " + 
< 				projectName + ".\n" + 
< 				"Crystal got the unexpected output:\n" + 
< 				e.getOutput() + "\n";
---
> 				_log.info("operation exception in running update local repository");
> 				_log.info("command: " + e.getCommand() + "\n path: " + e.getPath() + "\n repo name: " + repoName + "\n output: " + e.getOutput() + "\n");
> 				String errorMsg = "Crystal is having trouble executing\n" + e.getCommand() + "\nin " + e.getPath() + "\n for your " + repoName + " repository of project "
> 						+ projectName + ".\n" + "Crystal got the unexpected output:\n" + e.getOutput() + "\n";
157a207
> 			_log.info("trying to create local repository: " + localRepo);
158a209
> 			_log.info("finished creating local repository: " + localRepo);
161c212
< 	
---
> 
163c214,215
< 	 * @param prefs: the ProjectPreferences for the project to consider
---
> 	 * @param prefs
> 	 *            : the ProjectPreferences for the project to consider
167a220
> 		// _log.info("get local state");
169c222
< 		
---
> 
173c226
< 		
---
> 
183,187c236,237
< 		 * We are going to:
< 		 * 1.  update the local clone
< 		 * 2.  get the log from the local clone
< 		 * 3.  if the cloneString is local, we will also get heads and check for UNCHECKPOINTED
< 		 * 4.  check for MUST_RESOLVE or ALL_CLEAR and return
---
> 		 * We are going to: 1. update the local clone 2. get the log from the local clone 3. if the cloneString is local, we will also get heads and check for UNCHECKPOINTED 4.
> 		 * check for MUST_RESOLVE or ALL_CLEAR and return
189c239
< 		
---
> 
195c245
< 		else 
---
> 		else
197c247
< 		
---
> 
201,202c251
< 		
< 		// Step 1. Update the local clone.  If cloning fails, return ERROR state
---
> 		// Step 1. Update the local clone. If cloning fails, return ERROR state
205,206c254,255
< 			updateLocalRepositoryAndCheckCacheError(prefs.getEnvironment(), executablePath, mine, tempWorkPath, prefs.getEnvironment().getRemoteCmd(), 
< 					"your own", prefs.getEnvironment().getShortName());
---
> 			updateLocalRepositoryAndCheckCacheError(prefs.getEnvironment(), executablePath, mine, tempWorkPath, prefs.getEnvironment().getRemoteCmd(), "your own", 
> 			        prefs.getName());
207a257
> 			_log.info("failed to update local repository and check cache error in get local state");
209a260
> 			_log.info("failed to update local repository and check cache error in get local state");
212c263
< 		
---
> 		_log.info("successfully update local repository and check cache error in get local state");
214,216d264
< 		String[] logArgs = { "log" };
< 		Output output = RunIt.execute(executablePath, logArgs, mine, false);
< 		prefs.getEnvironment().setHistory(new RevisionHistory(output.getOutput(), kind));
218d265
< 		// TODO Step 2.5.  If the history has changed, find out if build or test fails.
219a267,282
> 		//String[] logArgs = { "log" };
> 		String[] hgLogArgs = { "log", "-r", "0:tip" };
> 		String[] gitLogArgs = { "log", "--reverse" };
> 		Output output;
> 		if (kind.equals(RepoKind.HG)) {
> 			output = RunIt.execute(executablePath, hgLogArgs, mine, false);
> 		} else if (kind.equals(RepoKind.GIT))
> 			output = RunIt.execute(executablePath, gitLogArgs, mine, false);
> 		else
> 			output = null;
> 		// if (kind.equals(RepoKind.GIT))
> 		// _log.info("log output: \n" + output.getOutput());
> 		prefs.getEnvironment().setHistory(new RevisionHistory(output.getOutput(), kind));
> 
> 		// TODO Step 2.5. If the history has changed, find out if build or test fails.
> 
222c285
< 			 * Check if repo status has non-empty response.  If it does, return UNCHECKPOINTED
---
> 			 * Check if repo status has non-empty response. If it does, return UNCHECKPOINTED
225c288
< 			output = RunIt.execute(executablePath, statusArgs , prefs.getEnvironment().getCloneString(), false);
---
> 			output = RunIt.execute(executablePath, statusArgs, prefs.getEnvironment().getCloneString(), false);
226a290
> 
235c299
< 					else 
---
> 					else
241,242c305,306
< 		
< 		// We can't find out the status, but we can find out if MUST_RESOLVE 
---
> 
> 		// We can't find out the status, but we can find out if MUST_RESOLVE
245c309
< 		 * Check if mine is two headed.  If it is, return MUST_RESOLVE
---
> 		 * Check if mine is two headed. If it is, return MUST_RESOLVE
248c312
< 		output = RunIt.execute(executablePath, headArgs, mine, false);	
---
> 		output = RunIt.execute(executablePath, headArgs, mine, false);
257c321
< 	
---
> 
259,261c323,326
< 	 * @param output: the output of "git heads"
< 	 * @return true iff the output indicated there are two heads.
< 	 * known problem: if the log message looks like the output of a changelog in the "git log" command, this method gets confused.
---
> 	 * @param output
> 	 *            : the output of "git heads"
> 	 * @return true iff the output indicated there are two heads. known problem: if the log message looks like the output of a changelog in the "git log" command, this method gets
> 	 *         confused.
264c329,330
< 		Pattern heads = Pattern.compile(".*^" + logLables.get(CheckpointLabels.CHANGESET) + " .*^" + logLables.get(CheckpointLabels.CHANGESET) + " .*", Pattern.DOTALL | Pattern.MULTILINE);
---
> 		Pattern heads = Pattern.compile(".*^" + logLables.get(CheckpointLabels.CHANGESET) + " .*^" + logLables.get(CheckpointLabels.CHANGESET) + " .*", Pattern.DOTALL
> 				| Pattern.MULTILINE);
271,273c337,343
< 	 * @param prefs: the ProjectPreferences for the project to consider.
< 	 * @param source: the repo to compare to.
< 	 * @param oldRelationship: the old Relationship, in String form.
---
> 	 * 
> 	 * @param prefs
> 	 *            : the ProjectPreferences for the project to consider.
> 	 * @param source
> 	 *            : the repo to compare to.
> 	 * @param oldRelationship
> 	 *            : the old Relationship, in String form.
275c345
< 	 * @throws Exception 
---
> 	 * @throws Exception
282c352
< 		Logger log = Logger.getLogger(AbstractStateChecker.class);
---
> 		_log.info("AbstractStateChecker::getRelationship(..)");
292c362
< 		if (kind.equals(RepoKind.HG)) 
---
> 		if (kind.equals(RepoKind.HG))
302,303c372,373
< //		String tempYourName = "tempYour_" + TimeUtility.getCurrentLSMRDateString();
< 		
---
> 		// String tempYourName = "tempYour_" + TimeUtility.getCurrentLSMRDateString();
> 
307,308c377
< 			updateLocalRepositoryAndCheckCacheError(source, executablePath, yours, tempWorkPath, source.getRemoteCmd(), 
< 					source.getShortName(), prefs.getEnvironment().getShortName());
---
> 			updateLocalRepositoryAndCheckCacheError(source, executablePath, yours, tempWorkPath, source.getRemoteCmd(), source.getShortName(), prefs.getName());
309a379,380
> 			if (kind.equals(RepoKind.GIT))
> 				_log.info("AbstractStateChecker::getRelationship(..) - ERROR: failed to update local repo and check cache error in get relationship");
312c383,385
< 		    return Relationship.ERROR + " " + e2.getMessage();
---
> 			if (kind.equals(RepoKind.GIT))
> 				_log.info("AbstractStateChecker::getRelationship(..) - ERROR: failed to update local repo and check cache error in get relationship");
> 			return Relationship.ERROR + " " + e2.getMessage();
314c387,388
< 
---
> 		if (kind.equals(RepoKind.GIT))
> 			_log.info("AbstractStateChecker::getRelationship(..) - successfully update local repo and check cache error in get relationship");
316,317c390,393
< 		String[] logArgs = { "log" };
< 		Output logOutput;
---
> 		//String[] logArgs = { "log" };
> 		String[] hgLogArgs = { "log", "-r", "0:tip" };
> 		String[] gitLogArgs = { "log", "--reverse" };
> 		Output logOutput = null;
319c395,398
< 		    logOutput = RunIt.execute(executablePath, logArgs, yours, false);
---
> 			if (kind.equals(RepoKind.HG)) {
> 				logOutput = RunIt.execute(executablePath, hgLogArgs, yours, false);
> 			} else if (kind.equals(RepoKind.GIT))
> 				logOutput = RunIt.execute(executablePath, gitLogArgs, yours, false);
321,322c400,401
<             return Relationship.ERROR + " Couldn't get the log: " + e2.getMessage();
<         }
---
> 			return Relationship.ERROR + " Couldn't get the log: " + e2.getMessage();
> 		}
324a404,407
> 		if (kind.equals(RepoKind.GIT)) {
> 			_log.info("your history\n" + yourHistory.toString());
> 
> 		}
330,332c413,417
< 		    return Relationship.ERROR + " Could not parse the history of your repository.";
< 				
< 		// TODO figure out if we need to check for compile and test whenever histories change: 
---
> 			return Relationship.ERROR + " Could not parse the history of your repository.";
> 
> 		if (kind.equals(RepoKind.GIT))
> 			_log.info("my history\n" + myHistory.toString());
> 		// TODO figure out if we need to check for compile and test whenever histories change:
335c420,424
< 		if (myHistory.equals(yourHistory))
---
> 		if (myHistory.equals(yourHistory)) {
> 			if (kind.equals(RepoKind.GIT)) {
> 				_log.info("\n yours: " + yours + "\nlog output: \n" + logOutput.getOutput());
> 				_log.info("same");
> 			}
337,338c426,431
< 		
< 		else if (myHistory.superHistory(yourHistory))
---
> 		} else if (myHistory.superHistory(yourHistory)) {
> 			if (kind.equals(RepoKind.GIT)) {
> 				_log.info("\n yours: " + yours + "\nlog output: \n" + logOutput.getOutput());
> 				_log.info("ahead");
> 			}
> 
340,341c433,439
< 		
< 		else if (myHistory.subHistory(yourHistory))
---
> 		}
> 
> 		else if (myHistory.subHistory(yourHistory)) {
> 			if (kind.equals(RepoKind.GIT)) {
> 				_log.info("\n yours: " + yours + "\nlog output: \n" + logOutput.getOutput());
> 				_log.info("behind");
> 			}
343,345c441,446
< 		
< 		// Well, we in one of {MERGE, CONFLICT, COMPILECONFLICT, TESTCONFLICT} relationships, so we are going to have to bite the bullet and make local clones.  
< 		
---
> 		} else if (kind.equals(RepoKind.GIT)) {
> 			_log.info("\n yours: " + yours + "\nlog output: \n" + logOutput.getOutput());
> 			_log.info("not same, ahead, or behind");
> 		}
> 		// Well, we in one of {MERGE, CONFLICT, COMPILECONFLICT, TESTCONFLICT} relationships, so we are going to have to bite the bullet and make local clones.
> 
348c449,451
< 			// Nothing has changed.  Keep old status.
---
> 			// Nothing has changed. Keep old status.
> 			if (kind.equals(RepoKind.GIT))
> 				_log.info("same with old relationship");
351c454
< 		// OK, things have changed.  We have to recompute.  
---
> 		// OK, things have changed. We have to recompute.
354c457
< 		
---
> 
358c461
< 		    output = RunIt.execute(executablePath, myArgs, tempWorkPath, false);
---
> 			output = RunIt.execute(executablePath, myArgs, tempWorkPath, false);
360,361c463,464
<             return Relationship.ERROR + " Couldn't make a temp clone: " + e2.getMessage();
<         }
---
> 			return Relationship.ERROR + " Couldn't make a temp clone: " + e2.getMessage();
> 		}
364c467,471
< 		    output = RunIt.execute(executablePath, pullArgs, tempWorkPath + tempMyName, false);
---
> 			output = RunIt.execute(executablePath, pullArgs, tempWorkPath + tempMyName, false);
> 			if (kind.equals(RepoKind.GIT)) {
> 				_log.info("\n path: " + tempWorkPath + tempMyName);
> 				_log.info("\n pull output: " + output.getOutput());
> 			}
366,370c473,477
<             return Relationship.ERROR + " Couldn't pull into my temp clone: " + e2.getMessage();
<         }
< 		
< 		if (output.getOutput().indexOf("(run '" + kind.toString().toLowerCase() 
< 				+ " heads' to see heads, '" + kind.toString().toLowerCase() + " merge' to merge)") >= 0) {
---
> 			return Relationship.ERROR + " Couldn't pull into my temp clone: " + e2.getMessage();
> 		}
> 
> 		if (output.getOutput().indexOf("(run '" + kind.toString().toLowerCase() + " heads' to see heads, '" + kind.toString().toLowerCase() + " merge' to merge)") >= 0
> 				|| output.getOutput().indexOf("Auto-merging") >= 0) {
374c481,482
< 			    output = RunIt.execute(executablePath, mergeArgs, tempWorkPath + tempMyName, false);
---
> 				if (kind.equals(RepoKind.HG))
> 					output = RunIt.execute(executablePath, mergeArgs, tempWorkPath + tempMyName, false);
376,377c484,485
< 	            return Relationship.ERROR + " Couldn't execute merge: " + e2.getMessage();
< 	        }
---
> 				return Relationship.ERROR + " Couldn't execute merge: " + e2.getMessage();
> 			}
379c487
< 			if (output.getOutput().indexOf("(branch merge, don't forget to commit)") >= 0) {
---
> 			if (output.getOutput().indexOf("(branch merge, don't forget to commit)") >= 0 || output.getOutput().indexOf("Merge made by recursive.") >= 0) {
383,408c491,514
< 				    try {
< 				        Output compileOutput = RunIt.tryCommand(compileCommand, tempWorkPath + tempMyName);
< 				        if (compileOutput.getStatus() != 0)
< 				            // if unsuccessful:
< 				            answer = Relationship.COMPILECONFLICT;
< 				        else {
< 				            // if successful try to test
< 				            String testCommand = prefs.getEnvironment().getTestCommand();
< 				            if (testCommand != null) {
< 				                Output testOutput = RunIt.tryCommand(testCommand, tempWorkPath + tempMyName);
< 				                if (testOutput.getStatus() != 0)
< 				                    // if unsuccessful:
< 				                    answer = Relationship.TESTCONFLICT;
< 				                else
< 				                    // if successful:
< 				                    answer = Relationship.MERGECLEAN;
< 				            }
< 				            else
< 				                // we don't know how to test
< 				                answer = Relationship.MERGECLEAN;
< 				        }
<                     } catch (IOException e2) {
<                         return Relationship.ERROR + " Had and IO error trying to either compile or run tests: " + e2.getMessage();
<                     }
< 				}
< 				else
---
> 					try {
> 						Output compileOutput = RunIt.tryCommand(compileCommand, tempWorkPath + tempMyName);
> 						if (compileOutput.getStatus() != 0)
> 							// if unsuccessful:
> 							answer = Relationship.COMPILECONFLICT;
> 						else {
> 							// if successful try to test
> 							String testCommand = prefs.getEnvironment().getTestCommand();
> 							if (testCommand != null) {
> 								Output testOutput = RunIt.tryCommand(testCommand, tempWorkPath + tempMyName);
> 								if (testOutput.getStatus() != 0)
> 									// if unsuccessful:
> 									answer = Relationship.TESTCONFLICT;
> 								else
> 									// if successful:
> 									answer = Relationship.MERGECLEAN;
> 							} else
> 								// we don't know how to test
> 								answer = Relationship.MERGECLEAN;
> 						}
> 					} catch (IOException e2) {
> 						return Relationship.ERROR + " Had and IO error trying to either compile or run tests: " + e2.getMessage();
> 					}
> 				} else
417,420c523,525
< 			log.error("Crystal is having trouble comparing" + mine + " and " + yours + "\n" + output.toString());
< 			String errorMsg = "Crystal is having trouble comparing\n" + 
< 			mine + " and " + yours + "\n" + 
< 			"for the repository " + source.getShortName() + " in project " + prefs.getEnvironment().getShortName() + ".\n";
---
> 			_log.error("Crystal is having trouble comparing" + mine + " and " + yours + "\n" + output.toString());
> 			String errorMsg = "Crystal is having trouble comparing\n" + mine + " and " + yours + "\n" + "for the repository " + source.getShortName() + " in project "
> 					+ prefs.getName() + ".\n";
425a531,532
> 		if (kind.equals(RepoKind.GIT))
> 			_log.info("the relationship: " + answer);
435c542
< 		
---
> 
441,444c548,555
< 		 * Creates a new GitOperationException 
< 		 * @param command: the git command that caused the exception.
< 		 * @param path: the path from which the command was run.
< 		 * @param output: the output of the command.
---
> 		 * Creates a new GitOperationException
> 		 * 
> 		 * @param command
> 		 *            : the git command that caused the exception.
> 		 * @param path
> 		 *            : the path from which the command was run.
> 		 * @param output
> 		 *            : the output of the command.
447,448c558
< 			super("Tried to execute \n\"" + command + "\"\n in \"" + path + "\"\n" +
< 					"but got the output\n" + output);
---
> 			super("Tried to execute \n\"" + command + "\"\n in \"" + path + "\"\n" + "but got the output\n" + output);
453c563
< 		
---
> 
460c570
< 		
---
> 
476,477c586
< 	
< 	
---
> 
diff -r crystalvc/src/crystal/server/GitLogParser.java crystal/src/crystal/server/GitLogParser.java
5a6,7
> import org.apache.log4j.Logger;
> 
13a16
>     private static Logger _log = Logger.getLogger(GitLogParser.class);
32c35,40
< 		return abstractParseLog(log, gitCheckpoint);
---
> 		HashMap<String, Checkpoint> checkpoints = abstractParseLog(log, gitCheckpoint);
> 		_log.info("\ncheck points with log:\n" + log);
> 		for (String s : checkpoints.keySet()) {
> 			_log.info("\nlog:\n" + s + "\ncheck points:\n" + checkpoints.get(s).toString());
> 		}
> 		return checkpoints;
diff -r crystalvc/src/crystal/util/RunIt.java crystal/src/crystal/util/RunIt.java
189c189
<         _log.info("RunIt::deleteDirectory(..) - deleting " + path);
---
>         _log.trace("RunIt::deleteDirectory(..) - deleting " + path);
202c202
<             _log.info("RunIt::deleteDirectory(..) - " + path + " deleted successfully");
---
>             _log.trace("RunIt::deleteDirectory(..) - " + path + " deleted successfully");
204c204
<             _log.info("RunIt::deleteDirectory(..) - deleting " + path + " failed");
---
>             _log.warn("RunIt::deleteDirectory(..) - deleting " + path + " failed");
264c264
<                     token += File.separator;    
---
>                     token += File.separator;  
267,270c267,273
<             if ((new File(token + File.separator + execPart + ".cmd")).exists()) {
<                 if (!(token.endsWith(File.separator)))
<                     token += File.separator;    
<                 return token + File.separator + execPart + ".cmd" + arguments;
---
>             if ((token.endsWith("cmd")) || (token.endsWith("cmd" + File.separator))) {
>                 token = token.replace("cmd","bin");
>                 if ((new File(token + File.separator + execPart + ".exe")).exists()) {
>                     if (!(token.endsWith(File.separator)))
>                         token += File.separator;  
>                     return token + File.separator + execPart + ".exe" + arguments;
>                 }
diff -r crystalvc/src/crystal/util/ValidInputChecker.java crystal/src/crystal/util/ValidInputChecker.java
10a11,12
> import org.apache.log4j.Logger;
> 
17,175c19,180
< 	
< 	/**
< 	 * Check if input url path is valid.
< 	 * @param path
< 	 * @return
< 	 */
< 	public static boolean checkUrl(String path) {
< 		try {
< 		    URL url = new URL(path);
< 		    URLConnection conn = url.openConnection();
< 		    conn.connect();
< 		} catch (MalformedURLException e) {
< 			return false;
< 		} catch (IOException e) {
< 			return false;
< 		}
< 		return true;
< 	}
< 	
< 	
< 	/**
< 	 * Check if there are duplicate data source in the same projectPreferences
< 	 * @param pref
< 	 * @param source
< 	 * @return
< 	 */
< 	public static boolean checkDataSourceNameDuplicate(ProjectPreferences pref, DataSource source) {
< 		Iterator<DataSource> i = pref.getDataSources().iterator();
< 		int count = 0;
< 		while(i.hasNext()) {
< 			if (i.next().equals(source))
< 				count++;
< 		}
< 		return count < 2;
< 	}
< 	/**
< 	 * Check if input command is valid command
< 	 * @param command
< 	 * @return
< 	 */
< 	public static boolean checkCommand(String command) {
< 		return command == null || command.trim().isEmpty() || RunIt.getExecutable(command) != null;
< 	}
< 	
< 	/**
< 	 * Check if there are duplicate projectPreferences name in the same clientPreferences
< 	 * @param prefs
< 	 * @param pref
< 	 * @return
< 	 */
< 	public static boolean checkProjectPreferencesNameDuplicate(ClientPreferences prefs, ProjectPreferences pref) {
< 		Iterator<ProjectPreferences> i = prefs.getProjectPreference().iterator();
< 		int count = 0;
< 		while (i.hasNext()) {
< 			if (i.next().equals(pref)) {
< 				count++;
< 			}
< 		}
< 		return count < 2;
< 	}
< 	
< 	
< 	/**
< 	 * Check if input path is directory path
< 	 * @param path
< 	 * @return
< 	 */
< 	public static boolean checkDirectoryPath(String path) {
< 		return (new File(path).exists()) && (new File(path).isDirectory());
< 	}
< 	
< 	
< 	/**
< 	 * Check if input string is correct representation for long value
< 	 * @param s
< 	 * @return
< 	 */
< 	public static boolean checkStringToLong(String s) {
< 		try {
< 			Long.valueOf(s);
< 		} catch (Exception e) {
< 			return false;
< 		}
< 		return true;
< 	}
< 	
< 	/**
< 	 * Check if given String is contained in given set
< 	 * @param s
< 	 * @param set
< 	 */
< 	public static void checkStringInSet(String s, Collection<String> set){
< 		if(s == null || !set.contains(s)){
< 			throw new IllegalArgumentException("Input: " + s + " is not contained in the set.");
< 		}
< 	}
< 
< 	/**
< 	 * Check if input object is null
< 	 * @param o
< 	 */
< 	public static void checkNullInput(Object o){
< 		if(o == null){
< 			throw new IllegalArgumentException("Null input");
< 		}
< 	}
< 	
< 	/**
< 	 * Check if input string is a valid string.
< 	 * @param s
< 	 */
< 	public static void checkValidStringInput(String s){
< 		if(s == null || s.trim().equals("")){
< 			throw new IllegalArgumentException("Invalid string input");
< 		}
< 	}
< 	
< 	/**
< 	 * Check if input integer is negative.
< 	 * @param n
< 	 */
< 	public static void checkNonNegativeNumberInput(int n){
< 		if(n < 0){
< 			throw new IllegalArgumentException("Negative integer input");
< 		}
< 	}
< 	
< 	/**
< 	 * Check if input string path is a file path
< 	 * @param path
< 	 */
< 	public static void checkValidFilePath(String path){
< 		checkValidPath(path, true);
< 	}
< 	
< 	/**
< 	 * Check if input string path is a directory path.
< 	 * 
< 	 * @param path
< 	 */
< 	public static void checkValidDirectoryPath(String path){
< 		checkValidPath(path, false);
< 	}
< 	
< 	/**
< 	 * Check if input string path is valid path for the given type.
< 	 * @param path
< 	 * @param isFile
< 	 */
< 	private static void checkValidPath(String path, boolean isFile){
< 		File f = new File(path);
< 		System.out.println(f.exists());
< 		if(isFile && !f.isFile()){
< 			throw new IllegalArgumentException("Given path is not path to file.");
< 		} else if (!isFile && !f.isDirectory()){
< 			throw new IllegalArgumentException("Given path is not path to directory.");
< 		}
< 		
< 	}
---
> 
>     private static Logger _log = Logger.getLogger(ValidInputChecker.class);
> 
>     /**
>      * Check if input url path is valid.
>      * @param path
>      * @return
>      */
>     public static boolean checkUrl(String path) {
>         try {
>             URL url = new URL(path);
>             URLConnection conn = url.openConnection();
>             conn.connect();
>         } catch (MalformedURLException e) {
>             return false;
>         } catch (IOException e) {
>             return false;
>         }
>         return true;
>     }
> 
> 
>     /**
>      * Check if there are duplicate data source in the same projectPreferences
>      * @param pref
>      * @param source
>      * @return
>      */
>     public static boolean checkDataSourceNameDuplicate(ProjectPreferences pref, DataSource source) {
>         Iterator<DataSource> i = pref.getDataSources().iterator();
>         int count = 0;
>         while(i.hasNext()) {
>             if (i.next().equals(source)) {
>                 count++;
>             }
>         }
>         return count < 2;
>     }
>     /**
>      * Check if input command is valid command
>      * @param command
>      * @return
>      */
>     public static boolean checkCommand(String command) {
>         return command == null || command.trim().isEmpty() || RunIt.getExecutable(command) != null;
>     }
> 
>     /**
>      * Check if there are duplicate projectPreferences name in the same clientPreferences
>      * @param prefs
>      * @param pref
>      * @return
>      */
>     public static boolean checkProjectPreferencesNameDuplicate(ClientPreferences prefs, ProjectPreferences pref) {
>         Iterator<ProjectPreferences> i = prefs.getProjectPreference().iterator();
>         int count = 0;
>         while (i.hasNext()) {
>             if (i.next().equals(pref)) {
>                 count++;
>             }
>         }
>         return count < 2;
>     }
> 
> 
>     /**
>      * Check if input path is directory path
>      * @param path
>      * @return
>      */
>     public static boolean checkDirectoryPath(String path) {
>         return (new File(path).exists()) && (new File(path).isDirectory());
>     }
> 
> 
>     /**
>      * Check if input string is correct representation for long value
>      * @param s
>      * @return
>      */
>     public static boolean checkStringToLong(String s) {
>         try {
>             Long.valueOf(s);
>         } catch (Exception e) {
>             return false;
>         }
>         return true;
>     }
> 
>     /**
>      * Check if given String is contained in given set
>      * @param s
>      * @param set
>      */
>     public static void checkStringInSet(String s, Collection<String> set){
>         if(s == null || !set.contains(s)){
>             throw new IllegalArgumentException("Input: " + s + " is not contained in the set.");
>         }
>     }
> 
>     /**
>      * Check if input object is null
>      * @param o
>      */
>     public static void checkNullInput(Object o){
>         if(o == null){
>             throw new IllegalArgumentException("Null input");
>         }
>     }
> 
>     /**
>      * Check if input string is a valid string.
>      * @param s
>      */
>     public static void checkValidStringInput(String s){
>         if(s == null || s.trim().equals("")){
>             throw new IllegalArgumentException("Invalid string input");
>         }
>     }
> 
>     /**
>      * Check if input integer is negative.
>      * @param n
>      */
>     public static void checkNonNegativeNumberInput(int n){
>         if(n < 0){
>             throw new IllegalArgumentException("Negative integer input");
>         }
>     }
> 
>     /**
>      * Check if input string path is a file path
>      * @param path
>      */
>     public static void checkValidFilePath(String path){
>         checkValidPath(path, true);
>     }
> 
>     /**
>      * Check if input string path is a directory path.
>      * 
>      * @param path
>      */
>     public static void checkValidDirectoryPath(String path){
>         checkValidPath(path, false);
>     }
> 
>     /**
>      * Check if input string path is valid path for the given type.
>      * @param path
>      * @param isFile
>      */
>     private static void checkValidPath(String path, boolean isFile){
>         File f = new File(path);
>         _log.debug("ValidInputChecker::checkValidFilePath( "+path+", "+isFile+" ) - "+f.exists());
>         if(isFile && !f.isFile()){
>             throw new IllegalArgumentException("Given path is not path to file.");
>         } else if (!isFile && !f.isDirectory()){
>             throw new IllegalArgumentException("Given path is not path to directory.");
>         }
> 
>     }
